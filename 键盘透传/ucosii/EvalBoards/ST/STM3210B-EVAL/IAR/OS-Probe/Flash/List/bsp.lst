###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       04/Jun/2018  23:13:18
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\BSP\bsp.c
#    Command line =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\BSP\bsp.c
#        -lCN
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=ARM7TDMI -e --fpu=None --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\
#        --cpu_mode thumb -Om --use_c++_inline
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\bsp.lst
#    Object file  =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\bsp.o
#
###############################################################################

C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\BSP\bsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     MICIRUM BOARD SUPPORT PACKAGE
      4          *
      5          *                             (c) Copyright 2007; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        BOARD SUPPORT PACKAGE
     18          *
     19          *                                     ST Microelectronics STM32
     20          *                                              with the
     21          *                                   STM3210B-EVAL Evaluation Board
     22          *
     23          * Filename      : bsp.c
     24          * Version       : V1.10
     25          * Programmer(s) : BAN
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                             INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          
     35          #define  BSP_MODULE
     36          #include <bsp.h>
     37          
     38          /*
     39          *********************************************************************************************************
     40          *                                            LOCAL DEFINES
     41          *********************************************************************************************************
     42          */
     43                                                                          /* -------------------- GPIOA PINS -------------------- */
     44          #define  BSP_GPIOA_PB_WAKEUP                      DEF_BIT_00
     45          #define  BSP_GPIOA_UART1_TX                       DEF_BIT_09
     46          #define  BSP_GPIOA_UART1_RX                       DEF_BIT_10
     47          #define  BSP_GPIOA_LCD_BL                         DEF_BIT_14
     48          
     49                                                                          /* -------------------- GPIOB PINS -------------------- */
     50          #define  BSP_GPIOB_LCD_CS                         DEF_BIT_02
     51          #define  BSP_GPIOB_TEMP_INT                       DEF_BIT_05
     52          #define  BSP_GPIOB_TEMP_SCL                       DEF_BIT_06
     53          #define  BSP_GPIOB_TEMP_SDA                       DEF_BIT_07
     54          #define  BSP_GPIOB_AUDIO_PWM                      DEF_BIT_08
     55          #define  BSP_GPIOB_PB_KEY                         DEF_BIT_09
     56          #define  BSP_GPIOB_LCD_SCL                        DEF_BIT_13
     57          #define  BSP_GPIOB_LCD_SDO                        DEF_BIT_14
     58          #define  BSP_GPIOB_LCD_SDI                        DEF_BIT_15
     59          
     60                                                                          /* -------------------- GPIOC PINS -------------------- */
     61          #define  BSP_GPIOC_POT                            DEF_BIT_04
     62          #define  BSP_GPIOC_LED1                           DEF_BIT_06
     63          #define  BSP_GPIOC_LED2                           DEF_BIT_07
     64          #define  BSP_GPIOC_LED3                           DEF_BIT_08
     65          #define  BSP_GPIOC_LED4                           DEF_BIT_09
     66          #define  BSP_GPIOC_PB_TAMPER                      DEF_BIT_13
     67          
     68                                                                          /* -------------------- GPIOD PINS -------------------- */
     69          #define  BSP_GPIOD_CAN_RX                         DEF_BIT_00
     70          #define  BSP_GPIOD_CAN_TX                         DEF_BIT_01
     71          #define  BSP_GPIOD_UART2_CTS                      DEF_BIT_03
     72          #define  BSP_GPIOD_UART2_RTS                      DEF_BIT_04
     73          #define  BSP_GPIOD_UART2_TX                       DEF_BIT_05
     74          #define  BSP_GPIOD_UART2_RX                       DEF_BIT_06
     75          #define  BSP_GPIOD_LCD_RS                         DEF_BIT_07
     76          #define  BSP_GPIOD_JOY_UP                         DEF_BIT_08
     77          #define  BSP_GPIOD_JOY_SEL                        DEF_BIT_12
     78          #define  BSP_GPIOD_JOY_DOWN                       DEF_BIT_14
     79          #define  BSP_GPIOD_LCD_RD                         DEF_BIT_15
     80          
     81                                                                          /* -------------------- GPIOE PINS -------------------- */
     82          #define  BSP_GPIOE_JOY_LEFT                       DEF_BIT_00
     83          #define  BSP_GPIOE_JOY_RIGHT                      DEF_BIT_01
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                           LOCAL CONSTANTS
     88          *********************************************************************************************************
     89          */
     90          
     91          
     92          /*
     93          *********************************************************************************************************
     94          *                                          LOCAL DATA TYPES
     95          *********************************************************************************************************
     96          */
     97          
     98          
     99          /*
    100          *********************************************************************************************************
    101          *                                            LOCAL TABLES
    102          *********************************************************************************************************
    103          */
    104          
    105          
    106          /*
    107          *********************************************************************************************************
    108          *                                       LOCAL GLOBAL VARIABLES
    109          *********************************************************************************************************
    110          */
    111          
    112          /*
    113          *********************************************************************************************************
    114          *                                      LOCAL FUNCTION PROTOTYPES
    115          *********************************************************************************************************
    116          */
    117          
    118          static  void  BSP_ADC_Init     (void);
    119          
    120          static  void  BSP_Joystick_Init(void);
    121          
    122          static  void  BSP_LED_Init     (void);
    123          
    124          static  void  BSP_PB_Init      (void);
    125          
    126          
    127          /*
    128          *********************************************************************************************************
    129          *                                     LOCAL CONFIGURATION ERRORS
    130          *********************************************************************************************************
    131          */
    132          
    133          
    134          /*
    135          *********************************************************************************************************
    136          *                                               BSP_Init()
    137          *
    138          * Description : Initialize the Board Support Package (BSP).
    139          *
    140          * Argument(s) : none.
    141          *
    142          * Return(s)   : none.
    143          *
    144          * Caller(s)   : Application.
    145          *
    146          * Note(s)     : (1) This function SHOULD be called before any other BSP function is called.
    147          *********************************************************************************************************
    148          */
    149          

   \                                 In section .text, align 2, keep-with-next
    150          void  BSP_Init (void)
    151          {
   \                     BSP_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    152              RCC_DeInit();
   \   00000002   0x.... 0x....      BL       RCC_DeInit
    153              RCC_HSEConfig(RCC_HSE_ON);
   \   00000006   0x2480             MOVS     R4,#+128
   \   00000008   0x0264             LSLS     R4,R4,#+9        ;; #+65536
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       RCC_HSEConfig
    154              RCC_WaitForHSEStartUp();
   \   00000010   0x.... 0x....      BL       RCC_WaitForHSEStartUp
    155          
    156          
    157              RCC_HCLKConfig(RCC_SYSCLK_Div1);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       RCC_HCLKConfig
    158              RCC_PCLK2Config(RCC_HCLK_Div1);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       RCC_PCLK2Config
    159              RCC_PCLK1Config(RCC_HCLK_Div2);
   \   00000020   0x09A0             LSRS     R0,R4,#+6
   \   00000022   0x.... 0x....      BL       RCC_PCLK1Config
    160              RCC_ADCCLKConfig(RCC_PCLK2_Div6);
   \   00000026   0x0860             LSRS     R0,R4,#+1
   \   00000028   0x.... 0x....      BL       RCC_ADCCLKConfig
    161              FLASH_SetLatency(FLASH_Latency_2);
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x.... 0x....      BL       FLASH_SetLatency
    162              FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
   \   00000032   0x2010             MOVS     R0,#+16
   \   00000034   0x.... 0x....      BL       FLASH_PrefetchBufferCmd
    163              RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
   \   00000038   0x21E0             MOVS     R1,#+224
   \   0000003A   0x0349             LSLS     R1,R1,#+13       ;; #+1835008
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       RCC_PLLConfig
    164              RCC_PLLCmd(ENABLE);
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       RCC_PLLCmd
    165          
    166              while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
   \                     ??BSP_Init_0: (+1)
   \   00000048   0x2039             MOVS     R0,#+57
   \   0000004A   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD0FA             BEQ      ??BSP_Init_0
    167                  ;
    168              }
    169          
    170              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x.... 0x....      BL       RCC_SYSCLKConfig
    171          
    172              while (RCC_GetSYSCLKSource() != 0x08) {
   \                     ??BSP_Init_1: (+1)
   \   00000058   0x.... 0x....      BL       RCC_GetSYSCLKSource
   \   0000005C   0x2808             CMP      R0,#+8
   \   0000005E   0xD1FB             BNE      ??BSP_Init_1
    173                  ;
    174              }
    175          
    176              BSP_ADC_Init();                                             /* Initialize the I/Os for the ADC      controls.       */
   \   00000060   0x.... 0x....      BL       BSP_ADC_Init
    177              BSP_LED_Init();                                             /* Initialize the I/Os for the LED      controls.       */
   \   00000064   0x.... 0x....      BL       BSP_LED_Init
    178              BSP_PB_Init();                                              /* Initialize the I/Os for the PB       control.        */
   \   00000068   0x.... 0x....      BL       BSP_PB_Init
    179              BSP_Joystick_Init();                                        /* Initialize the I/Os for the Joystick control.        */
   \   0000006C   0x.... 0x....      BL       BSP_Joystick_Init
    180          
    181              STM3210B_LCD_Init();
   \   00000070   0x.... 0x....      BL       STM3210B_LCD_Init
    182              LCD_Clear(0xFFFF);
   \   00000074   0x1E60             SUBS     R0,R4,#+1
   \   00000076   0x.... 0x....      BL       LCD_Clear
    183          }
   \   0000007A   0xBC10             POP      {R4}
   \   0000007C   0xBC08             POP      {R3}
   \   0000007E   0x4718             BX       R3               ;; return
    184          
    185          /*
    186          *********************************************************************************************************
    187          *                                            BSP_CPU_ClkFreq()
    188          *
    189          * Description : Read CPU registers to determine the CPU clock frequency of the chip.
    190          *
    191          * Argument(s) : none.
    192          *
    193          * Return(s)   : The CPU clock frequency, in Hz.
    194          *
    195          * Caller(s)   : Application.
    196          *
    197          * Note(s)     : none.
    198          *********************************************************************************************************
    199          */
    200          

   \                                 In section .text, align 2, keep-with-next
    201          CPU_INT32U  BSP_CPU_ClkFreq (void)
    202          {
   \                     BSP_CPU_ClkFreq: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    203              RCC_ClocksTypeDef  rcc_clocks;
    204          
    205          
    206              RCC_GetClocksFreq(&rcc_clocks);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       RCC_GetClocksFreq
    207          
    208              return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0xB005             ADD      SP,SP,#+20
   \   0000000E   0xBC08             POP      {R3}
   \   00000010   0x4718             BX       R3               ;; return
    209          }
    210          
    211          /*
    212          *********************************************************************************************************
    213          *********************************************************************************************************
    214          *                                         OS CORTEX-M3 FUNCTIONS
    215          *********************************************************************************************************
    216          *********************************************************************************************************
    217          */
    218          
    219          /*
    220          *********************************************************************************************************
    221          *                                         OS_CPU_SysTickClkFreq()
    222          *
    223          * Description : Get system tick clock frequency.
    224          *
    225          * Argument(s) : none.
    226          *
    227          * Return(s)   : Clock frequency (of system tick).
    228          *
    229          * Caller(s)   : BSP_Init().
    230          *
    231          * Note(s)     : none.
    232          *********************************************************************************************************
    233          */
    234          

   \                                 In section .text, align 2, keep-with-next
    235          INT32U  OS_CPU_SysTickClkFreq (void)
    236          {
   \                     OS_CPU_SysTickClkFreq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    237              INT32U  freq;
    238          
    239          
    240              freq = BSP_CPU_ClkFreq();
    241              return (freq);
   \   00000002   0x.... 0x....      BL       BSP_CPU_ClkFreq
   \   00000006   0xBC0A             POP      {R1,R3}
   \   00000008   0x4718             BX       R3               ;; return
    242          }
    243          
    244          /*
    245          *********************************************************************************************************
    246          *********************************************************************************************************
    247          *                                              ADC FUNCTIONS
    248          *********************************************************************************************************
    249          *********************************************************************************************************
    250          */
    251          
    252          /*
    253          *********************************************************************************************************
    254          *                                             BSP_ADC_Init()
    255          *
    256          * Description : Initialize the board's ADC
    257          *
    258          * Argument(s) : none.
    259          *
    260          * Return(s)   : none.
    261          *
    262          * Caller(s)   : BSP_Init().
    263          *
    264          * Note(s)     : none.
    265          *********************************************************************************************************
    266          */
    267          

   \                                 In section .text, align 2, keep-with-next
    268          static  void  BSP_ADC_Init (void)
    269          {
   \                     BSP_ADC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    270              ADC_InitTypeDef   adc_init;
    271              GPIO_InitTypeDef  gpio_init;
    272          
    273          
    274              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x0248             LSLS     R0,R1,#+9
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    275              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    276          
    277              gpio_init.GPIO_Pin  = GPIO_Pin_4;
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    278              gpio_init.GPIO_Mode = GPIO_Mode_AIN;
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x70C1             STRB     R1,[R0, #+3]
    279              GPIO_Init(GPIOC, &gpio_init);
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x....             LDR      R0,??DataTable9  ;; 0x40011000
   \   00000024   0x.... 0x....      BL       GPIO_Init
    280          
    281              adc_init.ADC_Mode               = ADC_Mode_Independent;
   \   00000028   0x9401             STR      R4,[SP, #+4]
    282              adc_init.ADC_ScanConvMode       = DISABLE;
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0x7101             STRB     R1,[R0, #+4]
    283              adc_init.ADC_ContinuousConvMode = ENABLE;
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x7141             STRB     R1,[R0, #+5]
    284              adc_init.ADC_ExternalTrigConv   = ADC_ExternalTrigConv_None;
   \   00000034   0x22E0             MOVS     R2,#+224
   \   00000036   0x0312             LSLS     R2,R2,#+12       ;; #+917504
   \   00000038   0x9203             STR      R2,[SP, #+12]
    285              adc_init.ADC_DataAlign          = ADC_DataAlign_Right;
   \   0000003A   0x9404             STR      R4,[SP, #+16]
    286              adc_init.ADC_NbrOfChannel       = 1;
   \   0000003C   0x7401             STRB     R1,[R0, #+16]
    287              ADC_Init(ADC1, &adc_init);
   \   0000003E   0x....             LDR      R4,??DataTable9_1  ;; 0x40012400
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       ADC_Init
    288          
    289              ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 1, ADC_SampleTime_13Cycles5);
   \   00000048   0x2302             MOVS     R3,#+2
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x210E             MOVS     R1,#+14
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       ADC_RegularChannelConfig
    290              ADC_Cmd(ADC1, ENABLE);
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       ADC_Cmd
    291              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    292          }
   \   00000064   0xB006             ADD      SP,SP,#+24
   \   00000066   0xBC10             POP      {R4}
   \   00000068   0xBC08             POP      {R3}
   \   0000006A   0x4718             BX       R3               ;; return
    293          
    294          
    295          /*
    296          *********************************************************************************************************
    297          *                                           BSP_ADC_GetStatus()
    298          *
    299          * Description : This function initializes the board's ADC
    300          *
    301          * Argument(s) : adc             ID of the ADC to probe.  For this board, the only legitimate value is 1.
    302          *
    303          * Return(s)   : The numerator of the binary fraction representing the result of the latest ADC conversion.
    304          *               This value will be a 12-bit value between 0x0000 and 0x0FFF, inclusive.
    305          *
    306          * Caller(s)   : Application.
    307          *
    308          * Note(s)     : none.
    309          *********************************************************************************************************
    310          */
    311          

   \                                 In section .text, align 2, keep-with-next
    312          CPU_INT16U  BSP_ADC_GetStatus (CPU_INT08U  adc)
    313          {
   \                     BSP_ADC_GetStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    314              CPU_INT16U  result;
    315          
    316          
    317              result = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    318          
    319              if (adc == 1) {
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD000             BEQ      ??BSP_ADC_GetStatus_0
   \   00000008   0x4770             BX       LR
    320                  result = ADC_GetConversionValue(ADC1);
   \                     ??BSP_ADC_GetStatus_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x....             LDR      R0,??DataTable9_1  ;; 0x40012400
   \   0000000E   0x.... 0x....      BL       ADC_GetConversionValue
    321              }
    322          
    323              return (result);
   \   00000012   0xBC0A             POP      {R1,R3}
   \   00000014   0x4718             BX       R3               ;; return
    324          }
    325          
    326          /*
    327          *********************************************************************************************************
    328          *********************************************************************************************************
    329          *                                               PB FUNCTIONS
    330          *********************************************************************************************************
    331          *********************************************************************************************************
    332          */
    333          
    334          /*
    335          *********************************************************************************************************
    336          *                                              BSP_PB_Init()
    337          *
    338          * Description : Initialize the board's PB.
    339          *
    340          * Argument(s) : none.
    341          *
    342          * Return(s)   : none.
    343          *
    344          * Caller(s)   : BSP_Init().
    345          *
    346          * Note(s)     : none.
    347          *********************************************************************************************************
    348          */
    349          

   \                                 In section .text, align 2, keep-with-next
    350          static  void  BSP_PB_Init (void)
    351          {
   \                     BSP_PB_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    352              GPIO_InitTypeDef  gpio_init;
    353          
    354          
    355              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    356              gpio_init.GPIO_Pin  = BSP_GPIOA_PB_WAKEUP;
   \   0000000C   0x466C             MOV      R4,SP
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x8020             STRH     R0,[R4, #+0]
    357              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000012   0x2504             MOVS     R5,#+4
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x70E0             STRB     R0,[R4, #+3]
    358              GPIO_Init(GPIOB, &gpio_init);
   \   00000018   0x....             LDR      R6,??DataTable10  ;; 0x40010c00
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       GPIO_Init
    359          
    360              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    361              gpio_init.GPIO_Pin  = BSP_GPIOB_PB_KEY;
   \   0000002A   0x01E8             LSLS     R0,R5,#+7
   \   0000002C   0x8020             STRH     R0,[R4, #+0]
    362              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x70E0             STRB     R0,[R4, #+3]
    363              GPIO_Init(GPIOB, &gpio_init);
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       GPIO_Init
    364          
    365              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    366              gpio_init.GPIO_Pin  = BSP_GPIOC_PB_TAMPER;
   \   00000042   0x02E8             LSLS     R0,R5,#+11
   \   00000044   0x8020             STRH     R0,[R4, #+0]
    367              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000046   0x70E5             STRB     R5,[R4, #+3]
    368              GPIO_Init(GPIOB, &gpio_init);
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0x.... 0x....      BL       GPIO_Init
    369          }
   \   00000050   0xBC73             POP      {R0,R1,R4-R6}
   \   00000052   0xBC08             POP      {R3}
   \   00000054   0x4718             BX       R3               ;; return
    370          
    371          /*
    372          *********************************************************************************************************
    373          *                                           BSP_PB_GetStatus()
    374          *
    375          * Description : Get the status of a push button on the board.
    376          *
    377          * Argument(s) : pb      The ID of the push button to probe
    378          *
    379          *                       1    probe the user push button
    380          *
    381          * Return(s)   : DEF_FALSE   if the push button is pressed.
    382          *               DEF_TRUE    if the push button is not pressed.
    383          *
    384          * Caller(s)   : Application.
    385          *
    386          * Note(s)     : none.
    387          *********************************************************************************************************
    388          */
    389          

   \                                 In section .text, align 2, keep-with-next
    390          CPU_BOOLEAN  BSP_PB_GetStatus (CPU_INT08U pb)
    391          {
   \                     BSP_PB_GetStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    392              CPU_BOOLEAN  status;
    393              CPU_INT32U   pin;
    394          
    395          
    396              status = DEF_FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    397          
    398              switch (pb) {
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD004             BEQ      ??BSP_PB_GetStatus_0
   \   00000008   0xD31C             BCC      ??BSP_PB_GetStatus_1
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD012             BEQ      ??BSP_PB_GetStatus_2
   \   0000000E   0xD309             BCC      ??BSP_PB_GetStatus_3
   \   00000010   0xE018             B        ??BSP_PB_GetStatus_1
    399                  case BSP_PB_ID_KEY:
    400                       pin = GPIO_ReadInputDataBit(GPIOB, BSP_GPIOB_PB_KEY);
   \                     ??BSP_PB_GetStatus_0: (+1)
   \   00000012   0x2180             MOVS     R1,#+128
   \   00000014   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000016   0x....             LDR      R0,??DataTable10  ;; 0x40010c00
   \   00000018   0x.... 0x....      BL       GPIO_ReadInputDataBit
    401                       if (pin == 0) {
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD111             BNE      ??BSP_PB_GetStatus_1
    402                           status = DEF_TRUE;
   \   00000020   0x2401             MOVS     R4,#+1
   \   00000022   0xE00F             B        ??BSP_PB_GetStatus_1
    403                       }
    404                       break;
    405          
    406                  case BSP_PB_ID_WAKEUP:
    407                       pin = GPIO_ReadInputDataBit(GPIOA, BSP_GPIOA_PB_WAKEUP);
   \                     ??BSP_PB_GetStatus_3: (+1)
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x....             LDR      R0,??DataTable10_1  ;; 0x40010800
   \   00000028   0x.... 0x....      BL       GPIO_ReadInputDataBit
    408                       if (pin == 0) {
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD109             BNE      ??BSP_PB_GetStatus_1
    409                           status = DEF_TRUE;
   \   00000030   0x2401             MOVS     R4,#+1
   \   00000032   0xE007             B        ??BSP_PB_GetStatus_1
    410                       }
    411                       break;
    412          
    413                  case BSP_PB_ID_TAMPER:
    414                       pin = GPIO_ReadInputDataBit(GPIOC, BSP_GPIOC_PB_TAMPER);
   \                     ??BSP_PB_GetStatus_2: (+1)
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x0189             LSLS     R1,R1,#+6        ;; #+8192
   \   00000038   0x....             LDR      R0,??DataTable9  ;; 0x40011000
   \   0000003A   0x.... 0x....      BL       GPIO_ReadInputDataBit
    415                       if (pin == 0) {
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD100             BNE      ??BSP_PB_GetStatus_1
    416                           status = DEF_TRUE;
   \   00000042   0x2401             MOVS     R4,#+1
    417                       }
    418                       break;
    419          
    420                  default:
    421                       break;
    422              }
    423          
    424              return (status);
   \                     ??BSP_PB_GetStatus_1: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xBC10             POP      {R4}
   \   00000048   0xBC08             POP      {R3}
   \   0000004A   0x4718             BX       R3               ;; return
    425          }
    426          
    427          /*
    428          *********************************************************************************************************
    429          *********************************************************************************************************
    430          *                                           JOYSTICK FUNCTIONS
    431          *********************************************************************************************************
    432          *********************************************************************************************************
    433          */
    434          
    435          /*
    436          *********************************************************************************************************
    437          *                                           BSP_Joystick_Init()
    438          *
    439          * Description : Initialize the board's joystick.
    440          *
    441          * Argument(s) : none.
    442          *
    443          * Return(s)   : none.
    444          *
    445          * Caller(s)   : BSP_Init().
    446          *
    447          * Note(s)     : none.
    448          *********************************************************************************************************
    449          */
    450          

   \                                 In section .text, align 2, keep-with-next
    451          static  void  BSP_Joystick_Init (void)
    452          {
   \                     BSP_Joystick_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    453              GPIO_InitTypeDef  gpio_init;
    454          
    455          
    456              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2060             MOVS     R0,#+96
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    457          
    458                                                                          /* Configure JOY_UP, JOY_SEL, JOY_DOWN.                 */
    459              gpio_init.GPIO_Pin  = BSP_GPIOD_JOY_UP | BSP_GPIOD_JOY_SEL | BSP_GPIOD_JOY_DOWN;
   \   0000000A   0x466C             MOV      R4,SP
   \   0000000C   0x20A2             MOVS     R0,#+162
   \   0000000E   0x01C0             LSLS     R0,R0,#+7        ;; #+20736
   \   00000010   0x8020             STRH     R0,[R4, #+0]
    460              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000012   0x2504             MOVS     R5,#+4
   \   00000014   0x70E5             STRB     R5,[R4, #+3]
    461              GPIO_Init(GPIOD, &gpio_init);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR      R0,??DataTable10_2  ;; 0x40011400
   \   0000001A   0x.... 0x....      BL       GPIO_Init
    462          
    463                                                                          /* Configure JOY_LEFT & JOY_RIGHT.                      */
    464              gpio_init.GPIO_Pin  = BSP_GPIOE_JOY_LEFT | BSP_GPIOE_JOY_RIGHT;
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    465              gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000022   0x70E5             STRB     R5,[R4, #+3]
    466              GPIO_Init(GPIOE, &gpio_init);
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x....             LDR      R0,??DataTable10_3  ;; 0x40011800
   \   00000028   0x.... 0x....      BL       GPIO_Init
    467          }
   \   0000002C   0xBC31             POP      {R0,R4,R5}
   \   0000002E   0xBC08             POP      {R3}
   \   00000030   0x4718             BX       R3               ;; return
    468          
    469          /*
    470          *********************************************************************************************************
    471          *                                        BSP_Joystick_GetStatus()
    472          *
    473          * Description : Get the status of the joystick on the board.
    474          *
    475          * Argument(s) : none.
    476          *
    477          * Return(s)   : Bit-mapped status of joystick :
    478          *
    479          *                   BSP_JOYSTICK_CENTER     if the joystick is being pressed.
    480          *                   BSP_JOYSTICK_LEFT       if the joystick is toggled left.
    481          *                   BSP_JOYSTICK_RIGHT      if the joystick is toggled right.
    482          *                   BSP_JOYSTICK_UP         if the joystick is toggled up.
    483          *                   BSP_JOYSTICK_DOWN       if the joystick is toggled down.
    484          *
    485          * Caller(s)   : Application.
    486          *
    487          * Note(s)     : none.
    488          *********************************************************************************************************
    489          */
    490          

   \                                 In section .text, align 2, keep-with-next
    491          CPU_INT32U  BSP_Joystick_GetStatus (void)
    492          {
   \                     BSP_Joystick_GetStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    493              CPU_BOOLEAN  pin;
    494              CPU_BOOLEAN  status;
    495          
    496              status = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    497          
    498              pin    = GPIO_ReadInputDataBit(GPIOE, BSP_GPIOE_JOY_RIGHT);
    499              if (pin == 0) {
   \   00000004   0x....             LDR      R5,??DataTable10_3  ;; 0x40011800
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE      ??BSP_Joystick_GetStatus_0
    500                  status |= BSP_JOYSTICK_LEFT;
   \   00000012   0x2404             MOVS     R4,#+4
    501              }
    502          
    503              pin    = GPIO_ReadInputDataBit(GPIOE, BSP_GPIOE_JOY_LEFT);
    504              if (pin == 0) {
   \                     ??BSP_Joystick_GetStatus_0: (+1)
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD102             BNE      ??BSP_Joystick_GetStatus_1
    505                  status |= BSP_JOYSTICK_RIGHT;
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x2408             MOVS     R4,#+8
   \   00000024   0x4304             ORRS     R4,R4,R0
    506              }
    507          
    508              pin    = GPIO_ReadInputDataBit(GPIOD, BSP_GPIOD_JOY_UP);
    509              if (pin == 0) {
   \                     ??BSP_Joystick_GetStatus_1: (+1)
   \   00000026   0x....             LDR      R5,??DataTable10_2  ;; 0x40011400
   \   00000028   0x0DA9             LSRS     R1,R5,#+22
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD102             BNE      ??BSP_Joystick_GetStatus_2
    510                  status |= BSP_JOYSTICK_UP;
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x2401             MOVS     R4,#+1
   \   00000038   0x4304             ORRS     R4,R4,R0
    511              }
    512          
    513              pin    = GPIO_ReadInputDataBit(GPIOD, BSP_GPIOD_JOY_DOWN);
    514              if (pin == 0) {
   \                     ??BSP_Joystick_GetStatus_2: (+1)
   \   0000003A   0x2180             MOVS     R1,#+128
   \   0000003C   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD102             BNE      ??BSP_Joystick_GetStatus_3
    515                  status |= BSP_JOYSTICK_DOWN;
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x2402             MOVS     R4,#+2
   \   0000004C   0x4304             ORRS     R4,R4,R0
    516              }
    517          
    518              pin    = GPIO_ReadInputDataBit(GPIOD, BSP_GPIOD_JOY_SEL);
    519              if (pin == 0) {
   \                     ??BSP_Joystick_GetStatus_3: (+1)
   \   0000004E   0x0CA9             LSRS     R1,R5,#+18
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD102             BNE      ??BSP_Joystick_GetStatus_4
    520                  status |= BSP_JOYSTICK_CENTER;
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x2410             MOVS     R4,#+16
   \   0000005E   0x4304             ORRS     R4,R4,R0
    521              }
    522          
    523              return (status);
   \                     ??BSP_Joystick_GetStatus_4: (+1)
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0xBC32             POP      {R1,R4,R5}
   \   00000064   0xBC08             POP      {R3}
   \   00000066   0x4718             BX       R3               ;; return
    524          }
    525          
    526          /*
    527          *********************************************************************************************************
    528          *********************************************************************************************************
    529          *                                              LED FUNCTIONS
    530          *********************************************************************************************************
    531          *********************************************************************************************************
    532          */
    533          
    534          /*
    535          *********************************************************************************************************
    536          *                                             BSP_LED_Init()
    537          *
    538          * Description : Initialize the I/O for the LEDs
    539          *
    540          * Argument(s) : none.
    541          *
    542          * Return(s)   : none.
    543          *
    544          * Caller(s)   : BSP_Init().
    545          *
    546          * Note(s)     : none.
    547          *********************************************************************************************************
    548          */
    549          

   \                                 In section .text, align 2, keep-with-next
    550          static  void  BSP_LED_Init (void)
    551          {
   \                     BSP_LED_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    552              GPIO_InitTypeDef  gpio_init;
    553          
    554          
    555              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    556          
    557              gpio_init.GPIO_Pin   = BSP_GPIOC_LED1 | BSP_GPIOC_LED2 | BSP_GPIOC_LED3 | BSP_GPIOC_LED4;
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x21F0             MOVS     R1,#+240
   \   0000000E   0x0089             LSLS     R1,R1,#+2        ;; #+960
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    558              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x7081             STRB     R1,[R0, #+2]
    559              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x70C1             STRB     R1,[R0, #+3]
    560              GPIO_Init(GPIOC, &gpio_init);
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x....             LDR      R0,??DataTable9  ;; 0x40011000
   \   0000001E   0x.... 0x....      BL       GPIO_Init
    561          }
   \   00000022   0xBC09             POP      {R0,R3}
   \   00000024   0x4718             BX       R3               ;; return
    562          
    563          /*
    564          *********************************************************************************************************
    565          *                                             BSP_LED_On()
    566          *
    567          * Description : Turn ON any or all the LEDs on the board.
    568          *
    569          * Argument(s) : led     The ID of the LED to control:
    570          *
    571          *                       0    turn ON all LEDs on the board
    572          *                       1    turn ON LED 1
    573          *                       2    turn ON LED 2
    574          *                       3    turn ON LED 3
    575          *                       4    turn ON LED 4
    576          *
    577          * Return(s)   : none.
    578          *
    579          * Caller(s)   : Application.
    580          *
    581          * Note(s)     : none.
    582          *********************************************************************************************************
    583          */
    584          

   \                                 In section .text, align 2, keep-with-next
    585          void  BSP_LED_On (CPU_INT08U led)
    586          {
   \                     BSP_LED_On: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    587              switch (led) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ      ??BSP_LED_On_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD00F             BEQ      ??BSP_LED_On_1
   \   0000000A   0xD309             BCC      ??BSP_LED_On_2
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD017             BEQ      ??BSP_LED_On_3
   \   00000010   0xD310             BCC      ??BSP_LED_On_4
   \   00000012   0xE01A             B        ??BSP_LED_On_5
    588                  case 0:
    589                       GPIO_SetBits(GPIOC, BSP_GPIOC_LED1 | BSP_GPIOC_LED2 | BSP_GPIOC_LED3 | BSP_GPIOC_LED4);
   \                     ??BSP_LED_On_0: (+1)
   \   00000014   0x21F0             MOVS     R1,#+240
   \   00000016   0x0089             LSLS     R1,R1,#+2        ;; #+960
   \   00000018   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   0000001A   0x.... 0x....      BL       GPIO_SetBits
    590                       break;
   \   0000001E   0xE014             B        ??BSP_LED_On_5
    591          
    592                  case 1:
    593                       GPIO_SetBits(GPIOC, BSP_GPIOC_LED1);
   \                     ??BSP_LED_On_2: (+1)
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   00000024   0x.... 0x....      BL       GPIO_SetBits
    594                       break;
   \   00000028   0xE00F             B        ??BSP_LED_On_5
    595          
    596                  case 2:
    597                       GPIO_SetBits(GPIOC, BSP_GPIOC_LED2);
   \                     ??BSP_LED_On_1: (+1)
   \   0000002A   0x2180             MOVS     R1,#+128
   \   0000002C   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   0000002E   0x.... 0x....      BL       GPIO_SetBits
    598                       break;
   \   00000032   0xE00A             B        ??BSP_LED_On_5
    599          
    600                  case 3:
    601                       GPIO_SetBits(GPIOC, BSP_GPIOC_LED3);
   \                     ??BSP_LED_On_4: (+1)
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000038   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   0000003A   0x.... 0x....      BL       GPIO_SetBits
    602                       break;
   \   0000003E   0xE004             B        ??BSP_LED_On_5
    603          
    604                  case 4:
    605                       GPIO_SetBits(GPIOC, BSP_GPIOC_LED4);
   \                     ??BSP_LED_On_3: (+1)
   \   00000040   0x2180             MOVS     R1,#+128
   \   00000042   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000044   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   00000046   0x.... 0x....      BL       GPIO_SetBits
    606                       break;
    607          
    608                  default:
    609                       break;
    610              }
    611          }
   \                     ??BSP_LED_On_5: (+1)
   \   0000004A   0xBC09             POP      {R0,R3}
   \   0000004C   0x4718             BX       R3               ;; return
    612          
    613          /*
    614          *********************************************************************************************************
    615          *                                              BSP_LED_Off()
    616          *
    617          * Description : Turn OFF any or all the LEDs on the board.
    618          *
    619          * Argument(s) : led     The ID of the LED to control:
    620          *
    621          *                       0    turn OFF all LEDs on the board
    622          *                       1    turn OFF LED 1
    623          *                       2    turn OFF LED 2
    624          *                       3    turn OFF LED 3
    625          *                       4    turn OFF LED 4
    626          *
    627          * Return(s)   : none.
    628          *
    629          * Caller(s)   : Application.
    630          *
    631          * Note(s)     : none.
    632          *********************************************************************************************************
    633          */
    634          

   \                                 In section .text, align 2, keep-with-next
    635          void  BSP_LED_Off (CPU_INT08U led)
    636          {
   \                     BSP_LED_Off: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    637              switch (led) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ      ??BSP_LED_Off_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD00F             BEQ      ??BSP_LED_Off_1
   \   0000000A   0xD309             BCC      ??BSP_LED_Off_2
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD017             BEQ      ??BSP_LED_Off_3
   \   00000010   0xD310             BCC      ??BSP_LED_Off_4
   \   00000012   0xE01A             B        ??BSP_LED_Off_5
    638                  case 0:
    639                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LED1 | BSP_GPIOC_LED2 | BSP_GPIOC_LED3 | BSP_GPIOC_LED4);
   \                     ??BSP_LED_Off_0: (+1)
   \   00000014   0x21F0             MOVS     R1,#+240
   \   00000016   0x0089             LSLS     R1,R1,#+2        ;; #+960
   \   00000018   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   0000001A   0x.... 0x....      BL       GPIO_ResetBits
    640                       break;
   \   0000001E   0xE014             B        ??BSP_LED_Off_5
    641          
    642                  case 1:
    643                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LED1);
   \                     ??BSP_LED_Off_2: (+1)
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   00000024   0x.... 0x....      BL       GPIO_ResetBits
    644                       break;
   \   00000028   0xE00F             B        ??BSP_LED_Off_5
    645          
    646                  case 2:
    647                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LED2);
   \                     ??BSP_LED_Off_1: (+1)
   \   0000002A   0x2180             MOVS     R1,#+128
   \   0000002C   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   0000002E   0x.... 0x....      BL       GPIO_ResetBits
    648                       break;
   \   00000032   0xE00A             B        ??BSP_LED_Off_5
    649          
    650                  case 3:
    651                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LED3);
   \                     ??BSP_LED_Off_4: (+1)
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000038   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   0000003A   0x.... 0x....      BL       GPIO_ResetBits
    652                       break;
   \   0000003E   0xE004             B        ??BSP_LED_Off_5
    653          
    654                  case 4:
    655                       GPIO_ResetBits(GPIOC, BSP_GPIOC_LED4);
   \                     ??BSP_LED_Off_3: (+1)
   \   00000040   0x2180             MOVS     R1,#+128
   \   00000042   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000044   0x....             LDR      R0,??DataTable10_4  ;; 0x40011000
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    656                       break;
    657          
    658                  default:
    659                       break;
    660              }
    661          }
   \                     ??BSP_LED_Off_5: (+1)
   \   0000004A   0xBC09             POP      {R0,R3}
   \   0000004C   0x4718             BX       R3               ;; return
    662          
    663          /*
    664          *********************************************************************************************************
    665          *                                            BSP_LED_Toggle()
    666          *
    667          * Description : TOGGLE any or all the LEDs on the board.
    668          *
    669          * Argument(s) : led     The ID of the LED to control:
    670          *
    671          *                       0    TOGGLE all LEDs on the board
    672          *                       1    TOGGLE LED 1
    673          *                       2    TOGGLE LED 2
    674          *                       3    TOGGLE LED 3
    675          *                       4    TOGGLE LED 4
    676          *
    677          * Return(s)   : none.
    678          *
    679          * Caller(s)   : Application.
    680          *
    681          * Note(s)     : none.
    682          *********************************************************************************************************
    683          */
    684          

   \                                 In section .text, align 2, keep-with-next
    685          void  BSP_LED_Toggle (CPU_INT08U led)
    686          {
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x....             LDR      R4,??DataTable10_4  ;; 0x40011000
   \   00000006   0xE009             B        ??BSP_LED_Toggle_0
    687              CPU_INT32U  pins;
    688          
    689          
    690              pins = GPIO_ReadOutputData(GPIOC);
    691          
    692              switch (led) {
    693                  case 0:
    694                       BSP_LED_Toggle(1);
   \                     ??BSP_LED_Toggle_1: (+1)
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF7FF 0xFFF9      BL       BSP_LED_Toggle
    695                       BSP_LED_Toggle(2);
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xF7FF 0xFFF6      BL       BSP_LED_Toggle
    696                       BSP_LED_Toggle(3);
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xF7FF 0xFFF3      BL       BSP_LED_Toggle
    697                       BSP_LED_Toggle(4);
   \   0000001A   0x2504             MOVS     R5,#+4
    698                       break;
   \                     ??BSP_LED_Toggle_0: (+1)
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       GPIO_ReadOutputData
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD0F0             BEQ      ??BSP_LED_Toggle_1
   \   00000026   0x2D02             CMP      R5,#+2
   \   00000028   0xD010             BEQ      ??BSP_LED_Toggle_2
   \   0000002A   0xD303             BCC      ??BSP_LED_Toggle_3
   \   0000002C   0x2D04             CMP      R5,#+4
   \   0000002E   0xD024             BEQ      ??BSP_LED_Toggle_4
   \   00000030   0xD318             BCC      ??BSP_LED_Toggle_5
   \   00000032   0xE02C             B        ??BSP_LED_Toggle_6
    699          
    700                  case 1:
    701                       if ((pins & BSP_GPIOC_LED1) == 0) {
   \                     ??BSP_LED_Toggle_3: (+1)
   \   00000034   0x0640             LSLS     R0,R0,#+25
   \   00000036   0xD404             BMI      ??BSP_LED_Toggle_7
    702                           GPIO_SetBits(  GPIOC, BSP_GPIOC_LED1);
   \   00000038   0x2140             MOVS     R1,#+64
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       GPIO_SetBits
   \   00000040   0xE025             B        ??BSP_LED_Toggle_6
    703                       } else {
    704                           GPIO_ResetBits(GPIOC, BSP_GPIOC_LED1);
   \                     ??BSP_LED_Toggle_7: (+1)
   \   00000042   0x2140             MOVS     R1,#+64
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
   \   0000004A   0xE020             B        ??BSP_LED_Toggle_6
    705                       }
    706                      break;
    707          
    708                  case 2:
    709                       if ((pins & BSP_GPIOC_LED2) == 0) {
   \                     ??BSP_LED_Toggle_2: (+1)
   \   0000004C   0x0600             LSLS     R0,R0,#+24
   \   0000004E   0xD404             BMI      ??BSP_LED_Toggle_8
    710                           GPIO_SetBits(  GPIOC, BSP_GPIOC_LED2);
   \   00000050   0x2180             MOVS     R1,#+128
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       GPIO_SetBits
   \   00000058   0xE019             B        ??BSP_LED_Toggle_6
    711                       } else {
    712                           GPIO_ResetBits(GPIOC, BSP_GPIOC_LED2);
   \                     ??BSP_LED_Toggle_8: (+1)
   \   0000005A   0x2180             MOVS     R1,#+128
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       GPIO_ResetBits
   \   00000062   0xE014             B        ??BSP_LED_Toggle_6
    713                       }
    714                      break;
    715          
    716                  case 3:
    717                       if ((pins & BSP_GPIOC_LED3) == 0) {
   \                     ??BSP_LED_Toggle_5: (+1)
   \   00000064   0x0DA1             LSRS     R1,R4,#+22
   \   00000066   0x4008             ANDS     R0,R0,R1
   \   00000068   0xD103             BNE      ??BSP_LED_Toggle_9
    718                           GPIO_SetBits(  GPIOC, BSP_GPIOC_LED3);
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       GPIO_SetBits
   \   00000070   0xE00D             B        ??BSP_LED_Toggle_6
    719                       } else {
    720                           GPIO_ResetBits(GPIOC, BSP_GPIOC_LED3);
   \                     ??BSP_LED_Toggle_9: (+1)
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       GPIO_ResetBits
   \   00000078   0xE009             B        ??BSP_LED_Toggle_6
    721                       }
    722                      break;
    723          
    724                  case 4:
    725                       if ((pins & BSP_GPIOC_LED4) == 0) {
   \                     ??BSP_LED_Toggle_4: (+1)
   \   0000007A   0x0D61             LSRS     R1,R4,#+21
   \   0000007C   0x4008             ANDS     R0,R0,R1
   \   0000007E   0xD103             BNE      ??BSP_LED_Toggle_10
    726                           GPIO_SetBits(  GPIOC, BSP_GPIOC_LED4);
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       GPIO_SetBits
   \   00000086   0xE002             B        ??BSP_LED_Toggle_6
    727                       } else {
    728                           GPIO_ResetBits(GPIOC, BSP_GPIOC_LED4);
   \                     ??BSP_LED_Toggle_10: (+1)
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       GPIO_ResetBits
    729                       }
    730                      break;
    731          
    732                  default:
    733                       break;
    734              }
    735          }
   \                     ??BSP_LED_Toggle_6: (+1)
   \   0000008E   0xBC31             POP      {R0,R4,R5}
   \   00000090   0xBC08             POP      {R3}
   \   00000092   0x4718             BX       R3               ;; return
    736          /*
    737          *********************************************************************************************************
    738          *********************************************************************************************************
    739          *                                           OS PROBE FUNCTIONS
    740          *********************************************************************************************************
    741          *********************************************************************************************************
    742          */
    743          
    744          /*
    745          *********************************************************************************************************
    746          *                                           OSProbe_TmrInit()
    747          *
    748          * Description : Select & initialize a timer for use with the uC/Probe Plug-In for uC/OS-II.
    749          *
    750          * Argument(s) : none.
    751          *
    752          * Return(s)   : none.
    753          *
    754          * Caller(s)   : OSProbe_Init().
    755          *
    756          * Note(s)     : none.
    757          *********************************************************************************************************
    758          */
    759          
    760          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
    761               (OS_PROBE_HOOKS_EN == 1))

   \                                 In section .text, align 2, keep-with-next
    762          void  OSProbe_TmrInit (void)
    763          {
   \                     OSProbe_TmrInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    764              TIM_TimeBaseInitTypeDef  tim_init;
    765          
    766          
    767              tim_init.TIM_Period        = 0xFFFF;
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x....             LDR      R1,??DataTable10_5  ;; 0xffff
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    768              tim_init.TIM_Prescaler     = 0x00;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    769              tim_init.TIM_ClockDivision = 0x0;
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    770              tim_init.TIM_CounterMode   = TIM_CounterMode_Up;
    771          
    772          #if (OS_PROBE_TIMER_SEL == 2)
    773              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    774          
    775              TIM_TimeBaseInit(TIM2, &tim_init);
   \   00000018   0x2480             MOVS     R4,#+128
   \   0000001A   0x05E4             LSLS     R4,R4,#+23       ;; #+1073741824
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       TIM_TimeBaseInit
    776              TIM_SetCounter(TIM2, 0);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       TIM_SetCounter
    777              TIM_PrescalerConfig(TIM2, 256, TIM_PSCReloadMode_Immediate);
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x0211             LSLS     R1,R2,#+8
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       TIM_PrescalerConfig
    778              TIM_Cmd(TIM2, ENABLE);
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       TIM_Cmd
    779          #elif (OS_PROBE_TIMER_SEL == 3)
    780              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    781          
    782              TIM_TimeBaseInit(TIM3, &tim_init);
    783              TIM_SetCounter(TIM3, 0);
    784              TIM_PrescalerConfig(TIM3, 256, TIM_PSCReloadMode_Immediate);
    785              TIM_Cmd(TIM3, ENABLE);
    786          #elif (OS_PROBE_TIMER_SEL == 4)
    787              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
    788          
    789              TIM_TimeBaseInit(TIM4, &tim_init);
    790              TIM_SetCounter(TIM4, 0);
    791              TIM_PrescalerConfig(TIM4, 256, TIM_PSCReloadMode_Immediate);
    792              TIM_Cmd(TIM4, ENABLE);
    793          #endif
    794          }
   \   0000003E   0xBC1F             POP      {R0-R4}
   \   00000040   0xBC08             POP      {R3}
   \   00000042   0x4718             BX       R3               ;; return
    795          #endif
    796          
    797          /*
    798          *********************************************************************************************************
    799          *                                            OSProbe_TmrRd()
    800          *
    801          * Description : Read the current counts of a 16-bit free running timer.
    802          *
    803          * Argument(s) : none.
    804          *
    805          * Return(s)   : The 16-bit counts of the timer in a 32-bit variable.
    806          *
    807          * Caller(s)   : OSProbe_TimeGetCycles().
    808          *
    809          * Note(s)     : none.
    810          *********************************************************************************************************
    811          */
    812          
    813          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
    814               (OS_PROBE_HOOKS_EN == 1))

   \                                 In section .text, align 2, keep-with-next
    815          CPU_INT32U  OSProbe_TmrRd (void)
    816          {
   \                     OSProbe_TmrRd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    817          #if (OS_PROBE_TIMER_SEL == 2)
    818          
    819              return ((CPU_INT32U)TIM_GetCounter(TIM2));
   \   00000002   0x2080             MOVS     R0,#+128
   \   00000004   0x05C0             LSLS     R0,R0,#+23       ;; #+1073741824
   \   00000006   0x.... 0x....      BL       TIM_GetCounter
   \   0000000A   0xBC0A             POP      {R1,R3}
   \   0000000C   0x4718             BX       R3               ;; return
    820          
    821          #elif (OS_PROBE_TIMER_SEL == 3)
    822          
    823              return ((CPU_INT32U)TIM_GetCounter(TIM3));
    824          
    825          #elif (OS_PROBE_TIMER_SEL == 4)
    826          
    827              return ((CPU_INT32U)TIM_GetCounter(TIM4));
    828          
    829          #endif
    830          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x0000FFFF         DC32     0xffff
    831          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BSP_ADC_GetStatus
         8   -> ADC_GetConversionValue
      32   BSP_ADC_Init
        32   -> ADC_Cmd
        32   -> ADC_Init
        32   -> ADC_RegularChannelConfig
        32   -> ADC_SoftwareStartConvCmd
        32   -> GPIO_Init
        32   -> RCC_APB2PeriphClockCmd
      24   BSP_CPU_ClkFreq
        24   -> RCC_GetClocksFreq
       8   BSP_Init
         8   -> BSP_ADC_Init
         8   -> BSP_Joystick_Init
         8   -> BSP_LED_Init
         8   -> BSP_PB_Init
         8   -> FLASH_PrefetchBufferCmd
         8   -> FLASH_SetLatency
         8   -> LCD_Clear
         8   -> RCC_ADCCLKConfig
         8   -> RCC_DeInit
         8   -> RCC_GetFlagStatus
         8   -> RCC_GetSYSCLKSource
         8   -> RCC_HCLKConfig
         8   -> RCC_HSEConfig
         8   -> RCC_PCLK1Config
         8   -> RCC_PCLK2Config
         8   -> RCC_PLLCmd
         8   -> RCC_PLLConfig
         8   -> RCC_SYSCLKConfig
         8   -> RCC_WaitForHSEStartUp
         8   -> STM3210B_LCD_Init
      16   BSP_Joystick_GetStatus
        16   -> GPIO_ReadInputDataBit
      16   BSP_Joystick_Init
        16   -> GPIO_Init
        16   -> RCC_APB2PeriphClockCmd
       8   BSP_LED_Init
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
       8   BSP_LED_Off
         8   -> GPIO_ResetBits
       8   BSP_LED_On
         8   -> GPIO_SetBits
      16   BSP_LED_Toggle
        16   -> BSP_LED_Toggle
        16   -> GPIO_ReadOutputData
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       8   BSP_PB_GetStatus
         8   -> GPIO_ReadInputDataBit
      24   BSP_PB_Init
        24   -> GPIO_Init
        24   -> RCC_APB2PeriphClockCmd
      24   OSProbe_TmrInit
        24   -> RCC_APB1PeriphClockCmd
        24   -> TIM_Cmd
        24   -> TIM_PrescalerConfig
        24   -> TIM_SetCounter
        24   -> TIM_TimeBaseInit
       8   OSProbe_TmrRd
         8   -> TIM_GetCounter
       8   OS_CPU_SysTickClkFreq
         8   -> BSP_CPU_ClkFreq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable9
       4  ??DataTable9_1
      22  BSP_ADC_GetStatus
     108  BSP_ADC_Init
      18  BSP_CPU_ClkFreq
     128  BSP_Init
     104  BSP_Joystick_GetStatus
      50  BSP_Joystick_Init
      38  BSP_LED_Init
      78  BSP_LED_Off
      78  BSP_LED_On
     148  BSP_LED_Toggle
      76  BSP_PB_GetStatus
      86  BSP_PB_Init
      68  OSProbe_TmrInit
      14  OSProbe_TmrRd
      10  OS_CPU_SysTickClkFreq

 
 1 058 bytes in section .text
 
 1 058 bytes of CODE memory

Errors: none
Warnings: none
