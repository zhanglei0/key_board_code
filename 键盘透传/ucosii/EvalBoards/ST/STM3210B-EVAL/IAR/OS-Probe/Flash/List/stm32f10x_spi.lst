###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       04/Jun/2018  23:13:34
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\CPU\ST\STM32\src\stm32f10x_spi.c
#    Command line =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\CPU\ST\STM32\src\stm32f10x_spi.c
#        -lCN
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=ARM7TDMI -e --fpu=None --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\
#        --cpu_mode thumb -Om --use_c++_inline
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\stm32f10x_spi.lst
#    Object file  =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\stm32f10x_spi.o
#
###############################################################################

C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\CPU\ST\STM32\src\stm32f10x_spi.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_spi.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0 
      5          * Date               : 05/23/2008
      6          * Description        : This file provides all the SPI firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
     15          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     16          *******************************************************************************/
     17          
     18          /* Includes ------------------------------------------------------------------*/
     19          #include "stm32f10x_spi.h"
     20          #include "stm32f10x_rcc.h"
     21          
     22          /* Private typedef -----------------------------------------------------------*/
     23          /* Private define ------------------------------------------------------------*/
     24          /* SPI SPE mask */
     25          #define CR1_SPE_Set          ((u16)0x0040)
     26          #define CR1_SPE_Reset        ((u16)0xFFBF)
     27          
     28          /* I2S I2SE mask */
     29          #define I2SCFGR_I2SE_Set     ((u16)0x0400)
     30          #define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
     31          
     32          /* SPI CRCNext mask */
     33          #define CR1_CRCNext_Set      ((u16)0x1000)
     34          
     35          /* SPI CRCEN mask */
     36          #define CR1_CRCEN_Set        ((u16)0x2000)
     37          #define CR1_CRCEN_Reset      ((u16)0xDFFF)
     38          
     39          /* SPI SSOE mask */
     40          #define CR2_SSOE_Set         ((u16)0x0004)
     41          #define CR2_SSOE_Reset       ((u16)0xFFFB)
     42          
     43          /* SPI registers Masks */
     44          #define CR1_CLEAR_Mask       ((u16)0x3040)
     45          #define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
     46          
     47          /* SPI or I2S mode selection masks */
     48          #define SPI_Mode_Select      ((u16)0xF7FF)
     49          #define I2S_Mode_Select      ((u16)0x0800)   
     50          
     51          /* Private macro -------------------------------------------------------------*/
     52          /* Private variables ---------------------------------------------------------*/
     53          /* Private function prototypes -----------------------------------------------*/
     54          /* Private functions ---------------------------------------------------------*/
     55          
     56          /*******************************************************************************
     57          * Function Name  : SPI_I2S_DeInit
     58          * Description    : Deinitializes the SPIx peripheral registers to their default
     59          *                  reset values (Affects also the I2Ss).
     60          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
     61          * Output         : None
     62          * Return         : None
     63          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
     65          {
   \                     SPI_I2S_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     66            /* Check the parameters */
     67            assert_param(IS_SPI_ALL_PERIPH(SPIx));
     68            
     69            switch (*(u32*)&SPIx)
   \   00000002   0x....             LDR      R1,??DataTable9  ;; 0x40003800
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD00F             BEQ      ??SPI_I2S_DeInit_0
   \   00000008   0x....             LDR      R1,??DataTable9_1  ;; 0x40003c00
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD016             BEQ      ??SPI_I2S_DeInit_1
   \   0000000E   0x....             LDR      R1,??DataTable9_2  ;; 0x40013000
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD11C             BNE      ??SPI_I2S_DeInit_2
     70            {
     71              case SPI1_BASE:
     72                /* Enable SPI1 reset state */
     73                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   00000014   0x0C8C             LSRS     R4,R1,#+18
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     74                /* Release SPI1 from reset state */
     75                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     76                break;
   \   00000026   0xE012             B        ??SPI_I2S_DeInit_2
     77          
     78              case SPI2_BASE:
     79                /* Enable SPI2 reset state */
     80                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \                     ??SPI_I2S_DeInit_0: (+1)
   \   00000028   0x0C0C             LSRS     R4,R1,#+16
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     81                /* Release SPI2 from reset state */
     82                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     83                break;
   \   0000003A   0xE008             B        ??SPI_I2S_DeInit_2
     84          
     85              case SPI3_BASE:
     86                /* Enable SPI3 reset state */
     87                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \                     ??SPI_I2S_DeInit_1: (+1)
   \   0000003C   0x0BCC             LSRS     R4,R1,#+15
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     88                /* Release SPI3 from reset state */
     89                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     90                break;
     91          
     92              default:
     93                break;
     94            }
     95          }
   \                     ??SPI_I2S_DeInit_2: (+1)
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0xBC08             POP      {R3}
   \   00000052   0x4718             BX       R3               ;; return
     96          
     97          /*******************************************************************************
     98          * Function Name  : SPI_Init
     99          * Description    : Initializes the SPIx peripheral according to the specified 
    100          *                  parameters in the SPI_InitStruct.
    101          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    102          *                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    103          *                    contains the configuration information for the specified
    104          *                    SPI peripheral.
    105          * Output         : None
    106          * Return         : None
    107          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    109          {
    110            u16 tmpreg = 0;
    111            
    112            /* check the parameters */
    113            assert_param(IS_SPI_ALL_PERIPH(SPIx));   
    114            
    115            /* Check the SPI parameters */
    116            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    117            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    118            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    119            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    120            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    121            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    122            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    123            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    124            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    125          
    126          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    127            /* Get the SPIx CR1 value */
    128            tmpreg = SPIx->CR1;
   \                     SPI_Init: (+1)
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
    129            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    130            tmpreg &= CR1_CLEAR_Mask;
    131            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    132               master/salve mode, CPOL and CPHA */
    133            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    134            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    135            /* Set LSBFirst bit according to SPI_FirstBit value */
    136            /* Set BR bits according to SPI_BaudRatePrescaler value */
    137            /* Set CPOL bit according to SPI_CPOL value */
    138            /* Set CPHA bit according to SPI_CPHA value */
    139            tmpreg |= (u16)((u32)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    140                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    141                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    142                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
    143            /* Write to SPIx CR1 */
    144            SPIx->CR1 = tmpreg;
   \   00000002   0x23C1             MOVS     R3,#+193
   \   00000004   0x019B             LSLS     R3,R3,#+6        ;; #+12352
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x880A             LDRH     R2,[R1, #+0]
   \   0000000A   0x431A             ORRS     R2,R2,R3
   \   0000000C   0x884B             LDRH     R3,[R1, #+2]
   \   0000000E   0x4313             ORRS     R3,R3,R2
   \   00000010   0x888A             LDRH     R2,[R1, #+4]
   \   00000012   0x431A             ORRS     R2,R2,R3
   \   00000014   0x88CB             LDRH     R3,[R1, #+6]
   \   00000016   0x4313             ORRS     R3,R3,R2
   \   00000018   0x890A             LDRH     R2,[R1, #+8]
   \   0000001A   0x431A             ORRS     R2,R2,R3
   \   0000001C   0x894B             LDRH     R3,[R1, #+10]
   \   0000001E   0x4313             ORRS     R3,R3,R2
   \   00000020   0x898A             LDRH     R2,[R1, #+12]
   \   00000022   0x431A             ORRS     R2,R2,R3
   \   00000024   0x89CB             LDRH     R3,[R1, #+14]
   \   00000026   0x4313             ORRS     R3,R3,R2
   \   00000028   0x8003             STRH     R3,[R0, #+0]
    145            
    146            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    147            SPIx->I2SCFGR &= SPI_Mode_Select;		
   \   0000002A   0x8B82             LDRH     R2,[R0, #+28]
   \   0000002C   0x....             LDR      R3,??DataTable9_3  ;; 0xf7ff
   \   0000002E   0x4013             ANDS     R3,R3,R2
   \   00000030   0x8383             STRH     R3,[R0, #+28]
    148          
    149          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    150            /* Write to SPIx CRCPOLY */
    151            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000032   0x8A09             LDRH     R1,[R1, #+16]
   \   00000034   0x8201             STRH     R1,[R0, #+16]
    152          }
   \   00000036   0x4770             BX       LR               ;; return
    153          
    154          /*******************************************************************************
    155          * Function Name  : I2S_Init
    156          * Description    : Initializes the SPIx peripheral according to the specified 
    157          *                  parameters in the I2S_InitStruct.
    158          * Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
    159          *                     (configured in I2S mode).
    160          *                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    161          *                    contains the configuration information for the specified
    162          *                    SPI peripheral configured in I2S mode.
    163          * Output         : None
    164          * Return         : None
    165          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    166          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    167          {
   \                     I2S_Init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x2601             MOVS     R6,#+1
    168            u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
    169            u32 tmp = 0;
    170            RCC_ClocksTypeDef RCC_Clocks;
    171             
    172            /* Check the I2S parameters */
    173            assert_param(IS_SPI_23_PERIPH(SPIx));
    174            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    175            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    176            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    177            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    178            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    179            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    180          
    181          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    182          
    183            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    184            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
   \   0000000A   0x8BA8             LDRH     R0,[R5, #+28]
   \   0000000C   0x....             LDR      R1,??DataTable9_4  ;; 0xf040
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x83A9             STRH     R1,[R5, #+28]
    185            SPIx->I2SPR = 0x0002;
   \   00000012   0x2702             MOVS     R7,#+2
   \   00000014   0x0038             MOVS     R0,R7
   \   00000016   0x8428             STRH     R0,[R5, #+32]
    186            
    187            /* Get the I2SCFGR register value */
    188            tmpreg = SPIx->I2SCFGR;
   \   00000018   0x8BA8             LDRH     R0,[R5, #+28]
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
    189            
    190            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    191            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   0000001E   0x8920             LDRH     R0,[R4, #+8]
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD102             BNE      ??I2S_Init_0
    192            {
    193              i2sodd = (u16)0;
   \   00000024   0x2000             MOVS     R0,#+0
    194              i2sdiv = (u16)2;   
   \   00000026   0x003A             MOVS     R2,R7
   \   00000028   0xE02A             B        ??I2S_Init_1
    195            }
    196            /* If the requested audio frequency is not the default, compute the prescaler */
    197            else
    198            {
    199              /* Check the frame length (For the Prescaler computing) */
    200              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0: (+1)
   \   0000002A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD000             BEQ      ??I2S_Init_2
    201              {
    202                /* Packet length is 16 bits */
    203                packetlength = 1;
    204              }
    205              else
    206              {
    207                /* Packet length is 32 bits */
    208                packetlength = 2;
   \   00000030   0x003E             MOVS     R6,R7
    209              }
    210              /* Get System Clock frequency */
    211              RCC_GetClocksFreq(&RCC_Clocks);
   \                     ??I2S_Init_2: (+1)
   \   00000032   0xA801             ADD      R0,SP,#+4
   \   00000034   0x.... 0x....      BL       RCC_GetClocksFreq
    212              
    213              /* Compute the Real divider depending on the MCLK output state with a flaoting point */
    214              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   00000038   0x8921             LDRH     R1,[R4, #+8]
   \   0000003A   0x9801             LDR      R0,[SP, #+4]
   \   0000003C   0x0082             LSLS     R2,R0,#+2
   \   0000003E   0x1810             ADDS     R0,R2,R0
   \   00000040   0x0040             LSLS     R0,R0,#+1
   \   00000042   0x88E2             LDRH     R2,[R4, #+6]
   \   00000044   0x023B             LSLS     R3,R7,#+8
   \   00000046   0x429A             CMP      R2,R3
   \   00000048   0xD106             BNE      ??I2S_Init_3
    215              {
    216                /* MCLK output is enabled */
    217                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   0000004A   0x0209             LSLS     R1,R1,#+8
   \   0000004C   0x.... 0x....      BL       __aeabi_uidiv
   \   00000050   0x1D40             ADDS     R0,R0,#+5
   \   00000052   0x0400             LSLS     R0,R0,#+16
   \   00000054   0x0C00             LSRS     R0,R0,#+16
   \   00000056   0xE006             B        ??I2S_Init_4
    218              }
    219              else
    220              {
    221                /* MCLK output is disabled */
    222                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_3: (+1)
   \   00000058   0x4371             MULS     R1,R6,R1
   \   0000005A   0x0149             LSLS     R1,R1,#+5
   \   0000005C   0x.... 0x....      BL       __aeabi_uidiv
   \   00000060   0x1D40             ADDS     R0,R0,#+5
   \   00000062   0x0400             LSLS     R0,R0,#+16
   \   00000064   0x0C00             LSRS     R0,R0,#+16
    223              }
    224              
    225              /* Remove the flaoting point */
    226              tmp = tmp/10;  
   \                     ??I2S_Init_4: (+1)
   \   00000066   0x210A             MOVS     R1,#+10
   \   00000068   0x.... 0x....      BL       __aeabi_uidiv
    227                
    228              /* Check the parity of the divider */
    229              i2sodd = (u16)(tmp & (u16)0x0001);
   \   0000006C   0x0002             MOVS     R2,R0
   \   0000006E   0x0011             MOVS     R1,R2
   \   00000070   0x07C9             LSLS     R1,R1,#+31
   \   00000072   0x0FC9             LSRS     R1,R1,#+31
    230             
    231              /* Compute the i2sdiv prescaler */
    232              i2sdiv = (u16)((tmp - i2sodd) / 2);
   \   00000074   0x000A             MOVS     R2,R1
   \   00000076   0x1A80             SUBS     R0,R0,R2
   \   00000078   0x0842             LSRS     R2,R0,#+1
   \   0000007A   0x0412             LSLS     R2,R2,#+16
   \   0000007C   0x0C12             LSRS     R2,R2,#+16
    233             
    234              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    235              i2sodd = (u16) (i2sodd << 8);
   \   0000007E   0x0208             LSLS     R0,R1,#+8
    236            }
    237            
    238            /* Test if the divider is 1 or 0 */
    239            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_1: (+1)
   \   00000080   0x1E91             SUBS     R1,R2,#+2
   \   00000082   0x29FE             CMP      R1,#+254
   \   00000084   0xD301             BCC      ??I2S_Init_5
    240            {
    241              /* Set the default values */
    242              i2sdiv = 2;
   \   00000086   0x003A             MOVS     R2,R7
    243              i2sodd = 0;
   \   00000088   0x2000             MOVS     R0,#+0
    244            }
    245          
    246            /* Write to SPIx I2SPR register the computed value */
    247            SPIx->I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct->I2S_MCLKOutput);  
   \                     ??I2S_Init_5: (+1)
   \   0000008A   0x4310             ORRS     R0,R0,R2
   \   0000008C   0x88E1             LDRH     R1,[R4, #+6]
   \   0000008E   0x4301             ORRS     R1,R1,R0
   \   00000090   0x8429             STRH     R1,[R5, #+32]
    248           
    249            /* Configure the I2S with the SPI_InitStruct values */
    250            tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct->I2S_Mode | \
    251                            I2S_InitStruct->I2S_Standard | I2S_InitStruct->I2S_DataFormat | \
    252                            I2S_InitStruct->I2S_CPOL);
    253           
    254            /* Write to SPIx I2SCFGR */  
    255            SPIx->I2SCFGR = tmpreg;                                    
   \   00000092   0x4668             MOV      R0,SP
   \   00000094   0x8800             LDRH     R0,[R0, #+0]
   \   00000096   0x8821             LDRH     R1,[R4, #+0]
   \   00000098   0x4301             ORRS     R1,R1,R0
   \   0000009A   0x8860             LDRH     R0,[R4, #+2]
   \   0000009C   0x4308             ORRS     R0,R0,R1
   \   0000009E   0x88A1             LDRH     R1,[R4, #+4]
   \   000000A0   0x4301             ORRS     R1,R1,R0
   \   000000A2   0x8960             LDRH     R0,[R4, #+10]
   \   000000A4   0x4308             ORRS     R0,R0,R1
   \   000000A6   0x02B9             LSLS     R1,R7,#+10
   \   000000A8   0x4301             ORRS     R1,R1,R0
   \   000000AA   0x83A9             STRH     R1,[R5, #+28]
    256          }
   \   000000AC   0xB007             ADD      SP,SP,#+28
   \   000000AE   0xBCF0             POP      {R4-R7}
   \   000000B0   0xBC08             POP      {R3}
   \   000000B2   0x4718             BX       R3               ;; return
    257          
    258          /*******************************************************************************
    259          * Function Name  : SPI_StructInit
    260          * Description    : Fills each SPI_InitStruct member with its default value.
    261          * Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
    262          *                    which will be initialized.
    263          * Output         : None
    264          * Return         : None
    265          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    267          {
    268          /*--------------- Reset SPI init structure parameters values -----------------*/
    269            /* Initialize the SPI_Direction member */
    270            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    271          
    272            /* initialize the SPI_Mode member */
    273            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    274          
    275            /* initialize the SPI_DataSize member */
    276            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    277          
    278            /* Initialize the SPI_CPOL member */
    279            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    280          
    281            /* Initialize the SPI_CPHA member */
    282            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
    283          
    284            /* Initialize the SPI_NSS member */
    285            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   0000000C   0x8141             STRH     R1,[R0, #+10]
    286          
    287            /* Initialize the SPI_BaudRatePrescaler member */
    288            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    289          
    290            /* Initialize the SPI_FirstBit member */
    291            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000010   0x81C1             STRH     R1,[R0, #+14]
    292          
    293            /* Initialize the SPI_CRCPolynomial member */
    294            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000012   0x2107             MOVS     R1,#+7
   \   00000014   0x8201             STRH     R1,[R0, #+16]
    295          }
   \   00000016   0x4770             BX       LR               ;; return
    296          
    297          /*******************************************************************************
    298          * Function Name  : I2S_StructInit
    299          * Description    : Fills each I2S_InitStruct member with its default value.
    300          * Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
    301          *                    which will be initialized.
    302          * Output         : None
    303          * Return         : None
    304          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    305          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    306          {
    307          /*--------------- Reset I2S init structure parameters values -----------------*/
    308            /* Initialize the I2S_Mode member */
    309            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    310            
    311            /* Initialize the I2S_Standard member */
    312            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    313            
    314            /* Initialize the I2S_DataFormat member */
    315            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    316            
    317            /* Initialize the I2S_MCLKOutput member */
    318            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    319            
    320            /* Initialize the I2S_AudioFreq member */
    321            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   0000000A   0x2202             MOVS     R2,#+2
   \   0000000C   0x8102             STRH     R2,[R0, #+8]
    322            
    323            /* Initialize the I2S_CPOL member */
    324            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   0000000E   0x8141             STRH     R1,[R0, #+10]
    325          }
   \   00000010   0x4770             BX       LR               ;; return
    326          
    327          /*******************************************************************************
    328          * Function Name  : SPI_Cmd
    329          * Description    : Enables or disables the specified SPI peripheral.
    330          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    331          *                  - NewState: new state of the SPIx peripheral. 
    332          *                    This parameter can be: ENABLE or DISABLE.
    333          * Output         : None
    334          * Return         : None
    335          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    336          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    337          {
    338            /* Check the parameters */
    339            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    340            assert_param(IS_FUNCTIONAL_STATE(NewState));
    341          
    342            if (NewState != DISABLE)
   \                     SPI_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xD003             BEQ      ??SPI_Cmd_0
    343            {
    344              /* Enable the selected SPI peripheral */
    345              SPIx->CR1 |= CR1_SPE_Set;
   \   00000006   0x2240             MOVS     R2,#+64
   \   00000008   0x430A             ORRS     R2,R2,R1
   \   0000000A   0x8002             STRH     R2,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    346            }
    347            else
    348            {
    349              /* Disable the selected SPI peripheral */
    350              SPIx->CR1 &= CR1_SPE_Reset;
   \                     ??SPI_Cmd_0: (+1)
   \   0000000E   0x....             LDR      R2,??DataTable9_5  ;; 0xffbf
   \   00000010   0x400A             ANDS     R2,R2,R1
   \   00000012   0x8002             STRH     R2,[R0, #+0]
    351            }
    352          }
   \   00000014   0x4770             BX       LR               ;; return
    353          
    354          /*******************************************************************************
    355          * Function Name  : I2S_Cmd
    356          * Description    : Enables or disables the specified SPI peripheral (in I2S mode).
    357          * Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
    358          *                  - NewState: new state of the SPIx peripheral. 
    359          *                    This parameter can be: ENABLE or DISABLE.
    360          * Output         : None
    361          * Return         : None
    362          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    363          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    364          {
    365            /* Check the parameters */
    366            assert_param(IS_SPI_23_PERIPH(SPIx));
    367            assert_param(IS_FUNCTIONAL_STATE(NewState));
    368          
    369            if (NewState != DISABLE)
   \                     I2S_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8B81             LDRH     R1,[R0, #+28]
   \   00000004   0xD004             BEQ      ??I2S_Cmd_0
    370            {
    371              /* Enable the selected SPI peripheral (in I2S mode) */
    372              SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \   0000000A   0x430A             ORRS     R2,R2,R1
   \   0000000C   0x8382             STRH     R2,[R0, #+28]
   \   0000000E   0x4770             BX       LR
    373            }
    374            else
    375            {
    376              /* Disable the selected SPI peripheral (in I2S mode) */
    377              SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
   \                     ??I2S_Cmd_0: (+1)
   \   00000010   0x....             LDR      R2,??DataTable9_6  ;; 0xfbff
   \   00000012   0x400A             ANDS     R2,R2,R1
   \   00000014   0x8382             STRH     R2,[R0, #+28]
    378            }
    379          }
   \   00000016   0x4770             BX       LR               ;; return
    380          
    381          /*******************************************************************************
    382          * Function Name  : SPI_I2S_ITConfig
    383          * Description    : Enables or disables the specified SPI/I2S interrupts.
    384          * Input          : - SPIx: where x can be :
    385          *                         - 1, 2 or 3 in SPI mode 
    386          *                         - 2 or 3 in I2S mode
    387          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
    388          *                    enabled or disabled. 
    389          *                    This parameter can be one of the following values:
    390          *                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    391          *                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    392          *                       - SPI_I2S_IT_ERR: Error interrupt mask
    393          *                  - NewState: new state of the specified SPI/I2S interrupt.
    394          *                    This parameter can be: ENABLE or DISABLE.
    395          * Output         : None
    396          * Return         : None
    397          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    398          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
    399          {
    400            u16 itpos = 0, itmask = 0 ;
    401          
    402            /* Check the parameters */
    403            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    404            assert_param(IS_FUNCTIONAL_STATE(NewState));
    405            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
    406          
    407            /* Get the SPI/I2S IT index */
    408            itpos = SPI_I2S_IT >> 4;
    409            /* Set the IT mask */
    410            itmask = (u16)((u16)1 << itpos);
   \                     SPI_I2S_ITConfig: (+1)
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x0909             LSRS     R1,R1,#+4
   \   00000004   0x408B             LSLS     R3,R3,R1
   \   00000006   0x041B             LSLS     R3,R3,#+16
   \   00000008   0x0C1B             LSRS     R3,R3,#+16
    411          
    412            if (NewState != DISABLE)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0x8881             LDRH     R1,[R0, #+4]
   \   0000000E   0xD002             BEQ      ??SPI_I2S_ITConfig_0
    413            {
    414              /* Enable the selected SPI/I2S interrupt */
    415              SPIx->CR2 |= itmask;
   \   00000010   0x430B             ORRS     R3,R3,R1
   \   00000012   0x8083             STRH     R3,[R0, #+4]
   \   00000014   0x4770             BX       LR
    416            }
    417            else
    418            {
    419              /* Disable the selected SPI/I2S interrupt */
    420              SPIx->CR2 &= (u16)~itmask;
   \                     ??SPI_I2S_ITConfig_0: (+1)
   \   00000016   0x4399             BICS     R1,R1,R3
   \   00000018   0x8081             STRH     R1,[R0, #+4]
    421            }
    422          }
   \   0000001A   0x4770             BX       LR               ;; return
    423          
    424          /*******************************************************************************
    425          * Function Name  : SPI_I2S_DMACmd
    426          * Description    : Enables or disables the SPIx/I2Sx DMA interface.
    427          * Input          : - SPIx: where x can be :
    428          *                         - 1, 2 or 3 in SPI mode 
    429          *                         - 2 or 3 in I2S mode
    430          *                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
    431          *                    to be enabled or disabled. 
    432          *                    This parameter can be any combination of the following values:
    433          *                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    434          *                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    435          *                  - NewState: new state of the selected SPI/I2S DMA transfer 
    436          *                    request.
    437          *                    This parameter can be: ENABLE or DISABLE.
    438          * Output         : None
    439          * Return         : None
    440          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    441          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
    442          {
    443            /* Check the parameters */
    444            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    447          
    448            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x8882             LDRH     R2,[R0, #+4]
   \   00000004   0xD002             BEQ      ??SPI_I2S_DMACmd_0
    449            {
    450              /* Enable the selected SPI/I2S DMA requests */
    451              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x8081             STRH     R1,[R0, #+4]
   \   0000000A   0x4770             BX       LR
    452            }
    453            else
    454            {
    455              /* Disable the selected SPI/I2S DMA requests */
    456              SPIx->CR2 &= (u16)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_0: (+1)
   \   0000000C   0x438A             BICS     R2,R2,R1
   \   0000000E   0x8082             STRH     R2,[R0, #+4]
    457            }
    458          }
   \   00000010   0x4770             BX       LR               ;; return
    459          
    460          /*******************************************************************************
    461          * Function Name  : SPI_I2S_SendData
    462          * Description    : Transmits a Data through the SPIx/I2Sx peripheral.
    463          * Input          : - SPIx: where x can be :
    464          *                         - 1, 2 or 3 in SPI mode 
    465          *                         - 2 or 3 in I2S mode
    466          *                  - Data : Data to be transmitted..
    467          * Output         : None
    468          * Return         : None
    469          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    470          void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
    471          {
    472            /* Check the parameters */
    473            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    474            
    475            /* Write in the DR register the data to be sent */
    476            SPIx->DR = Data;
   \                     SPI_I2S_SendData: (+1)
   \   00000000   0x8181             STRH     R1,[R0, #+12]
    477          }
   \   00000002   0x4770             BX       LR               ;; return
    478          
    479          /*******************************************************************************
    480          * Function Name  : SPI_I2S_ReceiveData
    481          * Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
    482          * Input          : - SPIx: where x can be :
    483          *                         - 1, 2 or 3 in SPI mode 
    484          *                         - 2 or 3 in I2S mode
    485          * Output         : None
    486          * Return         : The value of the received data.
    487          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    488          u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    492            
    493            /* Return the data in the DR register */
    494            return SPIx->DR;
   \                     SPI_I2S_ReceiveData: (+1)
   \   00000000   0x8980             LDRH     R0,[R0, #+12]
   \   00000002   0x4770             BX       LR               ;; return
    495          }
    496          
    497          /*******************************************************************************
    498          * Function Name  : SPI_NSSInternalSoftwareConfig
    499          * Description    : Configures internally by software the NSS pin for the selected 
    500          *                  SPI.
    501          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    502          *                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    503          *                    This parameter can be one of the following values:
    504          *                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
    505          *                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    506          * Output         : None
    507          * Return         : None
    508          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    509          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
    510          {
    511            /* Check the parameters */
    512            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    513            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    514          
    515            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig: (+1)
   \   00000000   0x....             LDR      R2,??DataTable9_7  ;; 0xfeff
   \   00000002   0x4291             CMP      R1,R2
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
   \   00000006   0xD004             BEQ      ??SPI_NSSInternalSoftwareConfig_0
    516            {
    517              /* Set NSS pin internally by software */
    518              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   00000008   0x2280             MOVS     R2,#+128
   \   0000000A   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \   0000000C   0x430A             ORRS     R2,R2,R1
   \   0000000E   0x8002             STRH     R2,[R0, #+0]
   \   00000010   0x4770             BX       LR
    519            }
    520            else
    521            {
    522              /* Reset NSS pin internally by software */
    523              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_0: (+1)
   \   00000012   0x400A             ANDS     R2,R2,R1
   \   00000014   0x8002             STRH     R2,[R0, #+0]
    524            }
    525          }
   \   00000016   0x4770             BX       LR               ;; return
    526          
    527          /*******************************************************************************
    528          * Function Name  : SPI_SSOutputCmd
    529          * Description    : Enables or disables the SS output for the selected SPI.
    530          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    531          *                  - NewState: new state of the SPIx SS output. 
    532          *                    This parameter can be: ENABLE or DISABLE.
    533          * Output         : None
    534          * Return         : None
    535          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    536          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    537          {
    538            /* Check the parameters */
    539            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    540            assert_param(IS_FUNCTIONAL_STATE(NewState));
    541          
    542            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xD003             BEQ      ??SPI_SSOutputCmd_0
    543            {
    544              /* Enable the selected SPI SS output */
    545              SPIx->CR2 |= CR2_SSOE_Set;
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x430A             ORRS     R2,R2,R1
   \   0000000A   0x8082             STRH     R2,[R0, #+4]
   \   0000000C   0x4770             BX       LR
    546            }
    547            else
    548            {
    549              /* Disable the selected SPI SS output */
    550              SPIx->CR2 &= CR2_SSOE_Reset;
   \                     ??SPI_SSOutputCmd_0: (+1)
   \   0000000E   0x....             LDR      R2,??DataTable9_8  ;; 0xfffb
   \   00000010   0x400A             ANDS     R2,R2,R1
   \   00000012   0x8082             STRH     R2,[R0, #+4]
    551            }
    552          }
   \   00000014   0x4770             BX       LR               ;; return
    553          
    554          /*******************************************************************************
    555          * Function Name  : SPI_DataSizeConfig
    556          * Description    : Configures the data size for the selected SPI.
    557          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    558          *                  - SPI_DataSize: specifies the SPI data size.
    559          *                    This parameter can be one of the following values:
    560          *                       - SPI_DataSize_16b: Set data frame format to 16bit
    561          *                       - SPI_DataSize_8b: Set data frame format to 8bit
    562          * Output         : None
    563          * Return         : None
    564          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    565          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
    566          {
    567            /* Check the parameters */
    568            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    569            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    570          
    571            /* Clear DFF bit */
    572            SPIx->CR1 &= (u16)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig: (+1)
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0x....             LDR      R3,??DataTable9_3  ;; 0xf7ff
   \   00000004   0x4013             ANDS     R3,R3,R2
   \   00000006   0x8003             STRH     R3,[R0, #+0]
    573            /* Set new DFF bit value */
    574            SPIx->CR1 |= SPI_DataSize;
   \   00000008   0x8802             LDRH     R2,[R0, #+0]
   \   0000000A   0x4311             ORRS     R1,R1,R2
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
    575          }
   \   0000000E   0x4770             BX       LR               ;; return
    576          
    577          /*******************************************************************************
    578          * Function Name  : SPI_TransmitCRC
    579          * Description    : Transmit the SPIx CRC value.
    580          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    581          * Output         : None
    582          * Return         : None
    583          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    584          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    585          {
    586            /* Check the parameters */
    587            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    588            
    589            /* Enable the selected SPI CRC transmission */
    590            SPIx->CR1 |= CR1_CRCNext_Set;
   \                     SPI_TransmitCRC: (+1)
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x8002             STRH     R2,[R0, #+0]
    591          }
   \   0000000A   0x4770             BX       LR               ;; return
    592          
    593          /*******************************************************************************
    594          * Function Name  : SPI_CalculateCRC
    595          * Description    : Enables or disables the CRC value calculation of the
    596          *                  transfered bytes.
    597          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    598          *                  - NewState: new state of the SPIx CRC value calculation.
    599          *                    This parameter can be: ENABLE or DISABLE.
    600          * Output         : None
    601          * Return         : None
    602          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    603          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    604          {
    605            /* Check the parameters */
    606            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    607            assert_param(IS_FUNCTIONAL_STATE(NewState));
    608          
    609            if (NewState != DISABLE)
   \                     SPI_CalculateCRC: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xD004             BEQ      ??SPI_CalculateCRC_0
    610            {
    611              /* Enable the selected SPI CRC calculation */
    612              SPIx->CR1 |= CR1_CRCEN_Set;
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0192             LSLS     R2,R2,#+6        ;; #+8192
   \   0000000A   0x430A             ORRS     R2,R2,R1
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0x4770             BX       LR
    613            }
    614            else
    615            {
    616              /* Disable the selected SPI CRC calculation */
    617              SPIx->CR1 &= CR1_CRCEN_Reset;
   \                     ??SPI_CalculateCRC_0: (+1)
   \   00000010   0x....             LDR      R2,??DataTable9_9  ;; 0xdfff
   \   00000012   0x400A             ANDS     R2,R2,R1
   \   00000014   0x8002             STRH     R2,[R0, #+0]
    618            }
    619          }
   \   00000016   0x4770             BX       LR               ;; return
    620          
    621          /*******************************************************************************
    622          * Function Name  : SPI_GetCRC
    623          * Description    : Returns the transmit or the receive CRC register value for
    624          *                  the specified SPI.
    625          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    626          *                  - SPI_CRC: specifies the CRC register to be read.
    627          *                    This parameter can be one of the following values:
    628          *                       - SPI_CRC_Tx: Selects Tx CRC register
    629          *                       - SPI_CRC_Rx: Selects Rx CRC register
    630          * Output         : None
    631          * Return         : The selected CRC register value..
    632          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    633          u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
    634          {
    635            u16 crcreg = 0;
    636          
    637            /* Check the parameters */
    638            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    639            assert_param(IS_SPI_CRC(SPI_CRC));
    640          
    641            if (SPI_CRC != SPI_CRC_Rx)
   \                     SPI_GetCRC: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD001             BEQ      ??SPI_GetCRC_0
    642            {
    643              /* Get the Tx CRC register */
    644              crcreg = SPIx->TXCRCR;
   \   00000004   0x8B00             LDRH     R0,[R0, #+24]
   \   00000006   0x4770             BX       LR
    645            }
    646            else
    647            {
    648              /* Get the Rx CRC register */
    649              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0: (+1)
   \   00000008   0x8A80             LDRH     R0,[R0, #+20]
    650            }
    651          
    652            /* Return the selected CRC register */
    653            return crcreg;
   \   0000000A   0x4770             BX       LR               ;; return
    654          }
    655          
    656          /*******************************************************************************
    657          * Function Name  : SPI_GetCRCPolynomial
    658          * Description    : Returns the CRC Polynomial register value for the specified SPI.
    659          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    660          * Output         : None
    661          * Return         : The CRC Polynomial register value.
    662          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    663          u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    664          {
    665            /* Check the parameters */
    666            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    667            
    668            /* Return the CRC polynomial register */
    669            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial: (+1)
   \   00000000   0x8A00             LDRH     R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    670          }
    671          
    672          /*******************************************************************************
    673          * Function Name  : SPI_BiDirectionalLineConfig
    674          * Description    : Selects the data transfer direction in bi-directional mode
    675          *                  for the specified SPI.
    676          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    677          *                  - SPI_Direction: specifies the data transfer direction in
    678          *                    bi-directional mode. 
    679          *                    This parameter can be one of the following values:
    680          *                       - SPI_Direction_Tx: Selects Tx transmission direction
    681          *                       - SPI_Direction_Rx: Selects Rx receive direction
    682          * Output         : None
    683          * Return         : None
    684          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    685          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
    686          {
    687            /* Check the parameters */
    688            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    689            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    690          
    691            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig: (+1)
   \   00000000   0x2280             MOVS     R2,#+128
   \   00000002   0x01D2             LSLS     R2,R2,#+7        ;; #+16384
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xD102             BNE      ??SPI_BiDirectionalLineConfig_0
    692            {
    693              /* Set the Tx only mode */
    694              SPIx->CR1 |= SPI_Direction_Tx;
   \   0000000A   0x430A             ORRS     R2,R2,R1
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0x4770             BX       LR
    695            }
    696            else
    697            {
    698              /* Set the Rx only mode */
    699              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_0: (+1)
   \   00000010   0x....             LDR      R2,??DataTable9_10  ;; 0xbfff
   \   00000012   0x400A             ANDS     R2,R2,R1
   \   00000014   0x8002             STRH     R2,[R0, #+0]
    700            }
    701          }
   \   00000016   0x4770             BX       LR               ;; return
    702          
    703          /*******************************************************************************
    704          * Function Name  : SPI_I2S_GetFlagStatus
    705          * Description    : Checks whether the specified SPI/I2S flag is set or not.
    706          * Input          : - SPIx: where x can be :
    707          *                         - 1, 2 or 3 in SPI mode 
    708          *                         - 2 or 3 in I2S mode
    709          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
    710          *                    This parameter can be one of the following values:
    711          *                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
    712          *                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
    713          *                       - SPI_I2S_FLAG_BSY: Busy flag.
    714          *                       - SPI_I2S_FLAG_OVR: Overrun flag.
    715          *                       - SPI_FLAG_MODF: Mode Fault flag.
    716          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    717          *                       - I2S_FLAG_UDR: Underrun Error flag.
    718          *                       - I2S_FLAG_CHSIDE: Channel Side flag.
    719          * Output         : None
    720          * Return         : The new state of SPI_I2S_FLAG (SET or RESET).
    721          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    722          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    723          {
   \                     SPI_I2S_GetFlagStatus: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    724            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    725          
    726            /* Check the parameters */
    727            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    728            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
    729          
    730            /* Check the status of the specified SPI/I2S flag */
    731            if ((SPIx->SR & SPI_I2S_FLAG) != (u16)RESET)
   \   00000004   0x8912             LDRH     R2,[R2, #+8]
   \   00000006   0x420A             TST      R2,R1
   \   00000008   0xD000             BEQ      ??SPI_I2S_GetFlagStatus_0
    732            {
    733              /* SPI_I2S_FLAG is set */
    734              bitstatus = SET;
   \   0000000A   0x2001             MOVS     R0,#+1
    735            }
    736            else
    737            {
    738              /* SPI_I2S_FLAG is reset */
    739              bitstatus = RESET;
    740            }
    741            /* Return the SPI_I2S_FLAG status */
    742            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    743          }
    744          
    745          /*******************************************************************************
    746          * Function Name  : SPI_I2S_ClearFlag
    747          * Description    : Clears the SPIx/I2Sx pending flags.
    748          * Input          : - SPIx: where x can be :
    749          *                         - 1, 2 or 3 in SPI mode 
    750          *                         - 2 or 3 in I2S mode
    751          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to clear. 
    752          *                    This parameter can be one of the following values:
    753          *                       - SPI_I2S_FLAG_OVR: Overrun flag 
    754          *                       - SPI_FLAG_MODF: Mode Fault flag.
    755          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    756          *                       - I2S_FLAG_UDR: Underrun Error flag.
    757          *                    Note: Before clearing OVR flag, it is mandatory to read 
    758          *                          SPI_I2S_DR register, so that the last data is not lost.
    759          * Output         : None
    760          * Return         : None
    761          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    762          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    763          {
    764            /* Check the parameters */
    765            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    766            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    767              
    768            /* SPI_FLAG_MODF flag clear */
    769            if(SPI_I2S_FLAG == SPI_FLAG_MODF)
   \                     SPI_I2S_ClearFlag: (+1)
   \   00000000   0x2920             CMP      R1,#+32
   \   00000002   0xD105             BNE      ??SPI_I2S_ClearFlag_0
    770            {
    771              /* Read SR register */
    772              (void)SPIx->SR;
   \   00000004   0x8901             LDRH     R1,[R0, #+8]
    773              
    774              /* Write on CR1 register */
    775              SPIx->CR1 |= CR1_SPE_Set; 
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0x2240             MOVS     R2,#+64
   \   0000000A   0x430A             ORRS     R2,R2,R1
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0x4770             BX       LR
    776            }
    777            /* SPI_I2S_FLAG_OVR flag or I2S_FLAG_UDR flag clear */
    778            else if ((SPI_I2S_FLAG == SPI_I2S_FLAG_OVR) || (SPI_I2S_FLAG == I2S_FLAG_UDR))  
   \                     ??SPI_I2S_ClearFlag_0: (+1)
   \   00000010   0x2940             CMP      R1,#+64
   \   00000012   0xD001             BEQ      ??SPI_I2S_ClearFlag_1
   \   00000014   0x2908             CMP      R1,#+8
   \   00000016   0xD101             BNE      ??SPI_I2S_ClearFlag_2
    779            {
    780              /* Read SR register  (Before clearing OVR flag, it is mandatory to read 
    781                 SPI_I2S_DR register)*/
    782              (void)SPIx->SR;
   \                     ??SPI_I2S_ClearFlag_1: (+1)
   \   00000018   0x8900             LDRH     R0,[R0, #+8]
   \   0000001A   0x4770             BX       LR
    783            }
    784            else /* SPI_FLAG_CRCERR flag clear */
    785            {
    786              /* Clear the selected SPI flag */
    787              SPIx->SR = (u16)~SPI_I2S_FLAG;
   \                     ??SPI_I2S_ClearFlag_2: (+1)
   \   0000001C   0x43CA             MVNS     R2,R1
   \   0000001E   0x8102             STRH     R2,[R0, #+8]
    788            }
    789          }
   \   00000020   0x4770             BX       LR               ;; return
    790          
    791          /*******************************************************************************
    792          * Function Name  : SPI_I2S_GetITStatus
    793          * Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
    794          * Input          : - SPIx: where x can be :
    795          *                         - 1, 2 or 3 in SPI mode 
    796          *                         - 2 or 3 in I2S mode
    797          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
    798          *                    This parameter can be one of the following values:
    799          *                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
    800          *                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
    801          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    802          *                       - SPI_IT_MODF: Mode Fault interrupt.
    803          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    804          *                       - I2S_IT_UDR: Underrun Error interrupt.
    805          * Output         : None
    806          * Return         : The new state of SPI_I2S_IT (SET or RESET).
    807          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    808          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    809          {
   \                     SPI_I2S_GetITStatus: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    810            ITStatus bitstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    811            u16 itpos = 0, itmask = 0, enablestatus = 0;
    812          
    813            /* Check the parameters */
    814            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    815            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
    816          
    817            /* Get the SPI/I2S IT index */
    818            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
    819          
    820            /* Get the SPI/I2S IT mask */
    821            itmask = SPI_I2S_IT >> 4;
    822            /* Set the IT mask */
    823            itmask = (u16)((u16)0x01 << itmask);
    824            /* Get the SPI_I2S_IT enable bit status */
    825            enablestatus = (SPIx->CR2 & itmask) ;
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x8895             LDRH     R5,[R2, #+4]
   \   0000000A   0x000E             MOVS     R6,R1
   \   0000000C   0x0936             LSRS     R6,R6,#+4
   \   0000000E   0x001C             MOVS     R4,R3
   \   00000010   0x40B4             LSLS     R4,R4,R6
   \   00000012   0x402C             ANDS     R4,R4,R5
    826          
    827            /* Check the status of the specified SPI/I2S interrupt */
    828            if (((SPIx->SR & itpos) != (u16)RESET) && enablestatus)
   \   00000014   0x8912             LDRH     R2,[R2, #+8]
   \   00000016   0x0709             LSLS     R1,R1,#+28
   \   00000018   0x0F09             LSRS     R1,R1,#+28
   \   0000001A   0x40CA             LSRS     R2,R2,R1
   \   0000001C   0x421A             TST      R2,R3
   \   0000001E   0xD002             BEQ      ??SPI_I2S_GetITStatus_0
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD000             BEQ      ??SPI_I2S_GetITStatus_0
    829            {
    830              /* SPI_I2S_IT is set */
    831              bitstatus = SET;
   \   00000024   0x0018             MOVS     R0,R3
    832            }
    833            else
    834            {
    835              /* SPI_I2S_IT is reset */
    836              bitstatus = RESET;
    837            }
    838            /* Return the SPI_I2S_IT status */
    839            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_0: (+1)
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0x4770             BX       LR               ;; return
    840          }
    841          
    842          /*******************************************************************************
    843          * Function Name  : SPI_I2S_ClearITPendingBit
    844          * Description    : Clears the SPIx/I2Sx interrupt pending bits.
    845          * Input          : - SPIx: where x can be :
    846          *                         - 1, 2 or 3 in SPI mode 
    847          *                         - 2 or 3 in I2S mode
    848          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt pending bit to clear.
    849          *                    This parameter can be one of the following values:
    850          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    851          *                       - SPI_IT_MODF: Mode Fault interrupt.
    852          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    853          *                       - I2S_IT_UDR: Underrun Error interrupt.
    854          * Output         : None
    855          * Return         : None
    856          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    857          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    858          {
    859            u16 itpos = 0;
    860          
    861            /* Check the parameters */
    862            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    863            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
    864          
    865            /* SPI_IT_MODF pending bit clear */
    866            if(SPI_I2S_IT == SPI_IT_MODF)
   \                     SPI_I2S_ClearITPendingBit: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0x2A55             CMP      R2,#+85
   \   00000004   0xD105             BNE      ??SPI_I2S_ClearITPendingBit_0
    867            {
    868              /* Read SR register */
    869              (void)SPIx->SR;
   \   00000006   0x8901             LDRH     R1,[R0, #+8]
    870              /* Write on CR1 register */
    871              SPIx->CR1 |= CR1_SPE_Set; 
   \   00000008   0x8801             LDRH     R1,[R0, #+0]
   \   0000000A   0x2240             MOVS     R2,#+64
   \   0000000C   0x430A             ORRS     R2,R2,R1
   \   0000000E   0x8002             STRH     R2,[R0, #+0]
   \   00000010   0x4770             BX       LR
    872            }
    873            /* SPI_I2S_IT_OVR or I2S_IT_UDR pending bit clear */ 
    874            else if((SPI_I2S_IT == SPI_I2S_IT_OVR) || (SPI_I2S_IT == I2S_IT_UDR))    
   \                     ??SPI_I2S_ClearITPendingBit_0: (+1)
   \   00000012   0x2A56             CMP      R2,#+86
   \   00000014   0xD001             BEQ      ??SPI_I2S_ClearITPendingBit_1
   \   00000016   0x2A53             CMP      R2,#+83
   \   00000018   0xD101             BNE      ??SPI_I2S_ClearITPendingBit_2
    875            {
    876              /* Read SR register */
    877              (void)(SPIx->SR);
   \                     ??SPI_I2S_ClearITPendingBit_1: (+1)
   \   0000001A   0x8900             LDRH     R0,[R0, #+8]
   \   0000001C   0x4770             BX       LR
    878            }  
    879            else   /* SPI_IT_CRCERR pending bit clear */
    880            {
    881              /* Get the SPI/I2S IT index */
    882              itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
    883              /* Clear the selected SPI/I2S interrupt pending bits */
    884              SPIx->SR = (u16)~itpos;
   \                     ??SPI_I2S_ClearITPendingBit_2: (+1)
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x0709             LSLS     R1,R1,#+28
   \   00000022   0x0F09             LSRS     R1,R1,#+28
   \   00000024   0x408A             LSLS     R2,R2,R1
   \   00000026   0x0412             LSLS     R2,R2,#+16
   \   00000028   0x0C12             LSRS     R2,R2,#+16
   \   0000002A   0x43D1             MVNS     R1,R2
   \   0000002C   0x8101             STRH     R1,[R0, #+8]
    885            }
    886          }
   \   0000002E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x0000F7FF         DC32     0xf7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x0000F040         DC32     0xf040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x0000FFBF         DC32     0xffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x0000FBFF         DC32     0xfbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x0000FEFF         DC32     0xfeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x0000FFFB         DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x0000DFFF         DC32     0xdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x0000BFFF         DC32     0xbfff
    887          
    888          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2S_Cmd
      48   I2S_Init
        48   -> RCC_GetClocksFreq
        48 __aeabi_uidiv
       0   I2S_StructInit
       0   SPI_BiDirectionalLineConfig
       0   SPI_CalculateCRC
       0   SPI_Cmd
       0   SPI_DataSizeConfig
       0   SPI_GetCRC
       0   SPI_GetCRCPolynomial
       0   SPI_I2S_ClearFlag
       0   SPI_I2S_ClearITPendingBit
       0   SPI_I2S_DMACmd
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   SPI_I2S_GetFlagStatus
      12   SPI_I2S_GetITStatus
       0   SPI_I2S_ITConfig
       0   SPI_I2S_ReceiveData
       0   SPI_I2S_SendData
       0   SPI_Init
       0   SPI_NSSInternalSoftwareConfig
       0   SPI_SSOutputCmd
       0   SPI_StructInit
       0   SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      24  I2S_Cmd
     180  I2S_Init
      18  I2S_StructInit
      24  SPI_BiDirectionalLineConfig
      24  SPI_CalculateCRC
      22  SPI_Cmd
      16  SPI_DataSizeConfig
      12  SPI_GetCRC
       4  SPI_GetCRCPolynomial
      34  SPI_I2S_ClearFlag
      48  SPI_I2S_ClearITPendingBit
      18  SPI_I2S_DMACmd
      84  SPI_I2S_DeInit
      14  SPI_I2S_GetFlagStatus
      42  SPI_I2S_GetITStatus
      28  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData
       4  SPI_I2S_SendData
      56  SPI_Init
      24  SPI_NSSInternalSoftwareConfig
      22  SPI_SSOutputCmd
      24  SPI_StructInit
      12  SPI_TransmitCRC

 
 782 bytes in section .text
 
 782 bytes of CODE memory

Errors: none
Warnings: none
