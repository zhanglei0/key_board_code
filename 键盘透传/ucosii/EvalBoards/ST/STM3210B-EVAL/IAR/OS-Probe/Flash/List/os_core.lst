###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       04/Jun/2018  23:13:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\uCOS-II\Source\os_core.c
#    Command line =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\uCOS-II\Source\os_core.c -lCN
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=ARM7TDMI -e --fpu=None --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\
#        -I
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\
#        --cpu_mode thumb -Om --use_c++_inline
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\os_core.lst
#    Object file  =  
#        C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\os_core.o
#
###############################################################################

C:\Users\zl\Desktop\¼üÅÌÍ¸´«\ucosii\uCOS-II\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #define  OS_GLOBALS
     26          #include <ucos_ii.h>

   \                                 In section .bss, align 4
   \   __absolute INT8U OSCPUUsage
   \                     OSCPUUsage:
   \   00000000                      DS8 1
   \   __absolute BOOLEAN OSStatRdy
   \                     OSStatRdy:
   \   00000001                      DS8 1
   \   __absolute INT8U OSIntNesting
   \                     OSIntNesting:
   \   00000002                      DS8 1
   \   __absolute INT8U OSLockNesting
   \                     OSLockNesting:
   \   00000003                      DS8 1
   \   __absolute INT8U OSPrioCur
   \                     OSPrioCur:
   \   00000004                      DS8 1
   \   __absolute INT8U OSPrioHighRdy
   \                     OSPrioHighRdy:
   \   00000005                      DS8 1
   \   __absolute INT8U OSRdyGrp
   \                     OSRdyGrp:
   \   00000006                      DS8 1
   \   __absolute BOOLEAN OSRunning
   \                     OSRunning:
   \   00000007                      DS8 1
   \   __absolute INT8U OSTaskCtr
   \                     OSTaskCtr:
   \   00000008                      DS8 1
   \   __absolute INT8U OSTickStepState
   \                     OSTickStepState:
   \   00000009                      DS8 1
   \   0000000A                      DS8 2
   \   __absolute INT8U OSRdyTbl[4]
   \                     OSRdyTbl:
   \   0000000C                      DS8 4
   \   __absolute INT32U OSCtxSwCtr
   \                     OSCtxSwCtr:
   \   00000010                      DS8 4
   \   __absolute INT32U OSIdleCtrMax
   \                     OSIdleCtrMax:
   \   00000014                      DS8 4
   \   __absolute INT32U OSIdleCtrRun
   \                     OSIdleCtrRun:
   \   00000018                      DS8 4
   \   __absolute INT32U volatile OSIdleCtr
   \                     OSIdleCtr:
   \   0000001C                      DS8 4
   \   __absolute OS_TCB *OSTCBCur
   \                     OSTCBCur:
   \   00000020                      DS8 4
   \   __absolute OS_TCB *OSTCBFreeList
   \                     OSTCBFreeList:
   \   00000024                      DS8 4
   \   __absolute OS_TCB *OSTCBHighRdy
   \                     OSTCBHighRdy:
   \   00000028                      DS8 4
   \   __absolute OS_TCB *OSTCBList
   \                     OSTCBList:
   \   0000002C                      DS8 4
   \   __absolute INT32U volatile OSTime
   \                     OSTime:
   \   00000030                      DS8 4
   \   __absolute OS_TCB OSTCBTbl[22]
   \                     OSTCBTbl:
   \   00000034                      DS8 2024

   \                                 In section .bss, align 4
   \   __absolute OS_EVENT *OSEventFreeList
   \                     OSEventFreeList:
   \   00000000                      DS8 4
   \   __absolute OS_EVENT OSEventTbl[10]
   \                     OSEventTbl:
   \   00000004                      DS8 320

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP OSFlagTbl[5]
   \                     OSFlagTbl:
   \   00000000                      DS8 140

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP *OSFlagFreeList
   \                     OSFlagFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_STK OSTaskStatStk[128]
   \                     OSTaskStatStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_STK OSTaskIdleStk[128]
   \                     OSTaskIdleStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB *OSTCBPrioTbl[32]
   \                     OSTCBPrioTbl:
   \   00000000                      DS8 128
     27          #endif
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                       PRIORITY RESOLUTION TABLE
     32          *
     33          * Note: Index into table is bit pattern to resolve highest priority
     34          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     35          *********************************************************************************************************
     36          */
     37          

   \                                 In section .text, align 4, keep-with-next
     38          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \   00000000   0x00 0x00          DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   00000017   0x00 0x03          DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   0000002E   0x01 0x00          DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02         
   \   00000045   0x00 0x01          DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00         
   \   0000005C   0x02 0x00          DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \              0x01 0x00    
   \              0x05 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01         
   \   00000073   0x00 0x02          DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x07    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00         
   \   0000008A   0x01 0x00          DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x05         
   \   000000A1   0x00 0x01          DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00         
   \   000000B8   0x03 0x00          DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   000000CF   0x00 0x04          DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   000000E6   0x01 0x00          DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02         
   \   000000FD   0x00 0x01          DC8 0, 1, 0
   \              0x00         
     39              0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x00 to 0x0F                             */
     40              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x10 to 0x1F                             */
     41              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x20 to 0x2F                             */
     42              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x30 to 0x3F                             */
     43              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x40 to 0x4F                             */
     44              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x50 to 0x5F                             */
     45              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x60 to 0x6F                             */
     46              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x70 to 0x7F                             */
     47              7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x80 to 0x8F                             */
     48              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x90 to 0x9F                             */
     49              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xA0 to 0xAF                             */
     50              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xB0 to 0xBF                             */
     51              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xC0 to 0xCF                             */
     52              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xD0 to 0xDF                             */
     53              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xE0 to 0xEF                             */
     54              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0        /* 0xF0 to 0xFF                             */
     55          };
     56          
     57          /*$PAGE*/
     58          /*
     59          *********************************************************************************************************
     60          *                                       FUNCTION PROTOTYPES
     61          *********************************************************************************************************
     62          */
     63          
     64          static  void  OS_InitEventList(void);
     65          
     66          static  void  OS_InitMisc(void);
     67          
     68          static  void  OS_InitRdyList(void);
     69          
     70          static  void  OS_InitTaskIdle(void);
     71          
     72          #if OS_TASK_STAT_EN > 0
     73          static  void  OS_InitTaskStat(void);
     74          #endif
     75          
     76          static  void  OS_InitTCBList(void);
     77          
     78          static  void  OS_SchedNew(void);
     79          
     80          /*$PAGE*/
     81          /*
     82          *********************************************************************************************************
     83          *                         GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     84          *
     85          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     86          *
     87          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     88          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     89          *                        type is irrelevant.
     90          *
     91          *              pname     is a pointer to an ASCII string that will receive the name of the semaphore,
     92          *                        mutex, mailbox or queue.  The string must be able to hold at least
     93          *                        OS_EVENT_NAME_SIZE characters.
     94          *
     95          *              perr      is a pointer to an error code that can contain one of the following values:
     96          *
     97          *                        OS_ERR_NONE                if the name was copied to 'pname'
     98          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
     99          *                                                   control block type.
    100          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    101          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    102          *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
    103          *
    104          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    105          *********************************************************************************************************
    106          */
    107          
    108          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    109          INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    110          {
   \                     OSEventNameGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
    111              INT8U      len;
    112          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    113              OS_CPU_SR  cpu_sr = 0;
    114          #endif
    115          
    116          
    117          
    118          #if OS_ARG_CHK_EN > 0
    119              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    120                  return (0);
    121              }
    122              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    123                  *perr = OS_ERR_PEVENT_NULL;
    124                  return (0);
    125              }
    126              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    127                  *perr = OS_ERR_PNAME_NULL;
    128                  return (0);
    129              }
    130          #endif
    131              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   00000008   0x....             LDR      R0,??DataTable7
   \   0000000A   0x7880             LDRB     R0,[R0, #+2]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??OSEventNameGet_0
    132                  *perr  = OS_ERR_NAME_GET_ISR;
   \   00000010   0x2011             MOVS     R0,#+17
   \   00000012   0x7030             STRB     R0,[R6, #+0]
    133                  return (0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE016             B        ??OSEventNameGet_1
    134              }
    135              switch (pevent->OSEventType) {
   \                     ??OSEventNameGet_0: (+1)
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD80F             BHI      ??OSEventNameGet_2
    136                  case OS_EVENT_TYPE_SEM:
    137                  case OS_EVENT_TYPE_MUTEX:
    138                  case OS_EVENT_TYPE_MBOX:
    139                  case OS_EVENT_TYPE_Q:
    140                       break;
    141          
    142                  default:
    143                       *perr = OS_ERR_EVENT_TYPE;
    144                       return (0);
    145              }
    146              OS_ENTER_CRITICAL();
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000024   0x0005             MOVS     R5,R0
    147              len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x310F             ADDS     R1,R1,#+15
   \   0000002A   0x0038             MOVS     R0,R7
   \   0000002C   0x.... 0x....      BL       OS_StrCopy
   \   00000030   0x0004             MOVS     R4,R0
    148              OS_EXIT_CRITICAL();
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       OS_CPU_SR_Restore
    149              *perr = OS_ERR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7030             STRB     R0,[R6, #+0]
    150              return (len);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xE002             B        ??OSEventNameGet_1
   \                     ??OSEventNameGet_2: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x7030             STRB     R0,[R6, #+0]
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??OSEventNameGet_1: (+1)
   \   00000046   0xBCF2             POP      {R1,R4-R7}
   \   00000048   0xBC08             POP      {R3}
   \   0000004A   0x4718             BX       R3               ;; return
    151          }
    152          #endif
    153          
    154          /*$PAGE*/
    155          /*
    156          *********************************************************************************************************
    157          *                         ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    158          *
    159          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    160          *
    161          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    162          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    163          *                        matter the actual type.
    164          *
    165          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    166          *                        mutex, mailbox or queue.  The string must be able to hold at least
    167          *                        OS_EVENT_NAME_SIZE characters.
    168          *
    169          *              perr      is a pointer to an error code that can contain one of the following values:
    170          *
    171          *                        OS_ERR_NONE                if the requested task is resumed
    172          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    173          *                                                   control block type.
    174          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    175          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    176          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    177          *
    178          * Returns    : None
    179          *********************************************************************************************************
    180          */
    181          
    182          #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
    183          void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    184          {
   \                     OSEventNameSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
    185              INT8U      len;
    186          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    187              OS_CPU_SR  cpu_sr = 0;
    188          #endif
    189          
    190          
    191          
    192          #if OS_ARG_CHK_EN > 0
    193              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    194                  return;
    195              }
    196              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    197                  *perr = OS_ERR_PEVENT_NULL;
    198                  return;
    199              }
    200              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    201                  *perr = OS_ERR_PNAME_NULL;
    202                  return;
    203              }
    204          #endif
    205              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   00000008   0x....             LDR      R0,??DataTable7
   \   0000000A   0x7880             LDRB     R0,[R0, #+2]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ      ??OSEventNameSet_0
    206                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000010   0x2012             MOVS     R0,#+18
   \   00000012   0x7030             STRB     R0,[R6, #+0]
    207                  return;
   \   00000014   0xE01E             B        ??OSEventNameSet_1
    208              }
    209              switch (pevent->OSEventType) {
   \                     ??OSEventNameSet_0: (+1)
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD80D             BHI      ??OSEventNameSet_2
    210                  case OS_EVENT_TYPE_SEM:
    211                  case OS_EVENT_TYPE_MUTEX:
    212                  case OS_EVENT_TYPE_MBOX:
    213                  case OS_EVENT_TYPE_Q:
    214                       break;
    215          
    216                  default:
    217                       *perr = OS_ERR_EVENT_TYPE;
    218                       return;
    219              }
    220              OS_ENTER_CRITICAL();
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x0005             MOVS     R5,R0
    221              len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    222              if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
   \   00000024   0x0038             MOVS     R0,R7
   \   00000026   0x.... 0x....      BL       OS_StrLen
   \   0000002A   0x2810             CMP      R0,#+16
   \   0000002C   0xDB08             BLT      ??OSEventNameSet_3
    223                  OS_EXIT_CRITICAL();
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       OS_CPU_SR_Restore
    224                  *perr = OS_ERR_EVENT_NAME_TOO_LONG;
   \   00000034   0x200B             MOVS     R0,#+11
   \   00000036   0x7030             STRB     R0,[R6, #+0]
    225                  return;
   \   00000038   0xE00C             B        ??OSEventNameSet_1
    226              }
   \                     ??OSEventNameSet_2: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
   \   0000003E   0xE009             B        ??OSEventNameSet_1
    227              (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
   \                     ??OSEventNameSet_3: (+1)
   \   00000040   0x0039             MOVS     R1,R7
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x300F             ADDS     R0,R0,#+15
   \   00000046   0x.... 0x....      BL       OS_StrCopy
    228              OS_EXIT_CRITICAL();
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       OS_CPU_SR_Restore
    229              *perr = OS_ERR_NONE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x7030             STRB     R0,[R6, #+0]
    230          }
   \                     ??OSEventNameSet_1: (+1)
   \   00000054   0xBCF1             POP      {R0,R4-R7}
   \   00000056   0xBC08             POP      {R3}
   \   00000058   0x4718             BX       R3               ;; return
    231          #endif
    232          
    233          /*$PAGE*/
    234          /*
    235          *********************************************************************************************************
    236          *                                      PEND ON MULTIPLE EVENTS
    237          *
    238          * Description: This function waits for multiple events.  If multiple events are ready at the start of the
    239          *              pend call, then all available events are returned as ready.  If the task must pend on the
    240          *              multiple events, then only the first posted or aborted event is returned as ready.
    241          *
    242          * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
    243          *
    244          *              pevents_rdy   is a pointer to an array to return which event control blocks are available
    245          *                            or ready.  The size of the array MUST be greater than or equal to the size
    246          *                            of the 'pevents_pend' array, including terminating NULL.
    247          *
    248          *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
    249          *                            events.  The size of the array MUST be greater than or equal to the size of
    250          *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
    251          *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
    252          *                            every available message-type event returns its messages in the 'pmsgs_rdy'
    253          *                            array at the same index as the event is returned in the 'pevents_rdy' array.
    254          *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
    255          *
    256          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    257          *                            wait for the resources up to the amount of time specified by this argument.
    258          *                            If you specify 0, however, your task will wait forever for the specified
    259          *                            events or, until the resources becomes available (or the events occur).
    260          *
    261          *              perr          is a pointer to where an error message will be deposited.  Possible error
    262          *                            messages are:
    263          *
    264          *                            OS_ERR_NONE         The call was successful and your task owns the resources
    265          *                                                or, the events you are waiting for occurred; check the
    266          *                                                'pevents_rdy' array for which events are available.
    267          *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
    268          *                                                'pevents_rdy' array for which events were aborted.
    269          *                            OS_ERR_TIMEOUT      The events were not received within the specified
    270          *                                                'timeout'.
    271          *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a 
    272          *                                                NULL pointer.
    273          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores, 
    274          *                                                mailboxes, and/or queues.
    275          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    276          *                                                would lead to a suspension.
    277          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
    278          *
    279          * Returns    : >  0          the number of events returned as ready or aborted.
    280          *              == 0          if no events are returned as ready because of timeout or upon error.
    281          *
    282          * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs : 
    283          *
    284          *                        semaphores, mailboxes, queues
    285          *
    286          *                 b. Return ALL available events and messages, if any
    287          *
    288          *                 c. Add    current task priority as pending to   each events's wait list
    289          *                      Performed in OS_EventTaskWaitMulti()
    290          *
    291          *                 d. Wait on any of multiple events
    292          *
    293          *                 e. Remove current task priority as pending from each events's wait list
    294          *                      Performed in OS_EventTaskRdy(), if events posted or aborted
    295          *
    296          *                 f. Return any event posted or aborted, if any
    297          *                      else
    298          *                    Return timeout
    299          *
    300          *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in 
    301          *                 case of any error(s).
    302          *********************************************************************************************************
    303          */
    304          /*$PAGE*/
    305          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
    306          INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
    307          {
   \                     OSEventPendMulti: (+1)
   \   00000000   0xB5FD             PUSH     {R0,R2-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    308              OS_EVENT  **pevents;
    309              OS_EVENT   *pevent;
    310          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    311              OS_Q       *pq;
    312          #endif
    313              BOOLEAN     events_rdy;
    314              INT16U      events_rdy_nbr;
    315              INT8U       events_stat;
    316          #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    317              OS_CPU_SR   cpu_sr = 0;
    318          #endif
    319          
    320          
    321          
    322          #if (OS_ARG_CHK_EN > 0)
    323              if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
    324                  return (0);
    325              }
    326              if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
    327                 *perr =  OS_ERR_PEVENT_NULL;
    328                  return (0);
    329              }
    330              if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
    331                 *perr =  OS_ERR_PEVENT_NULL;
    332                  return (0);
    333              }
    334              if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
    335                 *perr =  OS_ERR_PEVENT_NULL;
    336                  return (0);
    337              }
    338          #endif
    339          
    340             *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
   \   00000006   0x2700             MOVS     R7,#+0
   \   00000008   0x6027             STR      R7,[R4, #+0]
    341          
    342              pevents     =  pevents_pend;
   \   0000000A   0x9802             LDR      R0,[SP, #+8]
    343              pevent      = *pevents;
   \   0000000C   0x6805             LDR      R5,[R0, #+0]
   \   0000000E   0xE001             B        ??OSEventPendMulti_0
    344              while  (pevent != (OS_EVENT *)0) {
    345                  switch (pevent->OSEventType) {                  /* Validate event block types                  */
    346          #if (OS_SEM_EN  > 0)
    347                      case OS_EVENT_TYPE_SEM:
    348                           break;
    349          #endif
    350          #if (OS_MBOX_EN > 0)
    351                      case OS_EVENT_TYPE_MBOX:
    352                           break;
    353          #endif
    354          #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
    355                      case OS_EVENT_TYPE_Q:
    356                           break;
    357          #endif
    358          
    359                      case OS_EVENT_TYPE_MUTEX:                                            
    360                      case OS_EVENT_TYPE_FLAG:
    361                      default:           
    362                          *perr = OS_ERR_EVENT_TYPE;
    363                           return (0);
    364                  }
    365                  pevents++;
   \                     ??OSEventPendMulti_1: (+1)
   \   00000010   0x1D00             ADDS     R0,R0,#+4
    366                  pevent = *pevents;
   \   00000012   0x6805             LDR      R5,[R0, #+0]
   \                     ??OSEventPendMulti_0: (+1)
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD009             BEQ      ??OSEventPendMulti_2
   \   00000018   0x7829             LDRB     R1,[R5, #+0]
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD0F8             BEQ      ??OSEventPendMulti_1
   \   0000001E   0x2903             CMP      R1,#+3
   \   00000020   0xD0F6             BEQ      ??OSEventPendMulti_1
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x990A             LDR      R1,[SP, #+40]
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0xE0D8             B        ??OSEventPendMulti_3
    367              }
   \                     ??OSEventPendMulti_2: (+1)
   \   0000002C   0x....             LDR      R0,??DataTable7
   \   0000002E   0x7880             LDRB     R0,[R0, #+2]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD004             BEQ      ??OSEventPendMulti_4
    368          
    369              if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
    370                 *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x990A             LDR      R1,[SP, #+40]
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    371                  return (0);
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0xE0CF             B        ??OSEventPendMulti_3
    372              }
    373              if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
   \                     ??OSEventPendMulti_4: (+1)
   \   0000003E   0x....             LDR      R0,??DataTable7
   \   00000040   0x78C0             LDRB     R0,[R0, #+3]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD004             BEQ      ??OSEventPendMulti_5
    374                 *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
   \   00000046   0x200D             MOVS     R0,#+13
   \   00000048   0x990A             LDR      R1,[SP, #+40]
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    375                  return (0);
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0xE0C6             B        ??OSEventPendMulti_3
    376              }
    377          
    378          /*$PAGE*/
    379              OS_ENTER_CRITICAL();
   \                     ??OSEventPendMulti_5: (+1)
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000054   0x9001             STR      R0,[SP, #+4]
    380              events_rdy     =  OS_FALSE;
   \   00000056   0x0039             MOVS     R1,R7
    381              events_rdy_nbr =  0;
   \   00000058   0x003E             MOVS     R6,R7
    382              events_stat    =  OS_STAT_RDY;
   \   0000005A   0x9700             STR      R7,[SP, #+0]
    383              pevents        =  pevents_pend;
   \   0000005C   0x9802             LDR      R0,[SP, #+8]
    384              pevent         = *pevents;
   \   0000005E   0x6805             LDR      R5,[R0, #+0]
   \   00000060   0xE005             B        ??OSEventPendMulti_6
    385              while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
    386                  switch (pevent->OSEventType) {
    387          #if (OS_SEM_EN > 0)
    388                      case OS_EVENT_TYPE_SEM:
    389                           if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
    390                               pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
    391                              *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
    392                                events_rdy   =  OS_TRUE;
    393                              *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
    394                                events_rdy_nbr++;
    395          
    396                           } else {
    397                                events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
    398                           }
    399                           break;
    400          #endif
    401          
    402          #if (OS_MBOX_EN > 0)
    403                      case OS_EVENT_TYPE_MBOX:
    404                           if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
    405                                                                  /* ... return available message,           ... */
    406                              *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
    407                               pevent->OSEventPtr  = (void *)0;
    408                              *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
    409                                events_rdy         =  OS_TRUE;
    410                                events_rdy_nbr++;
    411          
    412                           } else {
    413                                events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
   \                     ??OSEventPendMulti_7: (+1)
   \   00000062   0x9A00             LDR      R2,[SP, #+0]
   \   00000064   0x2302             MOVS     R3,#+2
   \   00000066   0x4313             ORRS     R3,R3,R2
   \   00000068   0x9300             STR      R3,[SP, #+0]
    414                           }
    415                           break;
    416          #endif
    417          
    418          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
    419                      case OS_EVENT_TYPE_Q:
    420                           pq = (OS_Q *)pevent->OSEventPtr;
    421                           if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
    422                                                                  /* ... return available message,           ... */
    423                              *pmsgs_rdy++ = (void *)*pq->OSQOut++;
    424                               if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
    425                                   pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
    426                               }
    427                               pq->OSQEntries--;                  /* Update number of queue entries              */
    428                              *pevents_rdy++ = pevent;            /* ... and return available queue event        */
    429                                events_rdy   = OS_TRUE;
    430                                events_rdy_nbr++;
    431          
    432                           } else {
    433                                events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
    434                           }
    435                           break;
    436          #endif
    437          
    438                      case OS_EVENT_TYPE_MUTEX:                                            
    439                      case OS_EVENT_TYPE_FLAG:
    440                      default:           
    441                           OS_EXIT_CRITICAL();
    442                          *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
    443                          *perr        =  OS_ERR_EVENT_TYPE;
    444                           return (events_rdy_nbr);
    445                  }
    446                  pevents++;
   \                     ??OSEventPendMulti_8: (+1)
   \   0000006A   0x1D00             ADDS     R0,R0,#+4
    447                  pevent = *pevents;
   \   0000006C   0x6805             LDR      R5,[R0, #+0]
   \                     ??OSEventPendMulti_6: (+1)
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD027             BEQ      ??OSEventPendMulti_9
   \   00000072   0x782A             LDRB     R2,[R5, #+0]
   \   00000074   0x2A01             CMP      R2,#+1
   \   00000076   0xD016             BEQ      ??OSEventPendMulti_10
   \   00000078   0x2A03             CMP      R2,#+3
   \   0000007A   0xD000             BEQ      .+4
   \   0000007C   0xE081             B        ??OSEventPendMulti_11
   \   0000007E   0x892A             LDRH     R2,[R5, #+8]
   \   00000080   0x0013             MOVS     R3,R2
   \   00000082   0xD00B             BEQ      ??OSEventPendMulti_12
   \   00000084   0x1E51             SUBS     R1,R2,#+1
   \   00000086   0x8129             STRH     R1,[R5, #+8]
   \   00000088   0x6025             STR      R5,[R4, #+0]
   \   0000008A   0x1D24             ADDS     R4,R4,#+4
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x9A03             LDR      R2,[SP, #+12]
   \   00000090   0x6017             STR      R7,[R2, #+0]
   \   00000092   0x9A03             LDR      R2,[SP, #+12]
   \   00000094   0x1D12             ADDS     R2,R2,#+4
   \   00000096   0x9203             STR      R2,[SP, #+12]
   \   00000098   0x1C76             ADDS     R6,R6,#+1
   \   0000009A   0xE7E6             B        ??OSEventPendMulti_8
   \                     ??OSEventPendMulti_12: (+1)
   \   0000009C   0x9A00             LDR      R2,[SP, #+0]
   \   0000009E   0x2301             MOVS     R3,#+1
   \   000000A0   0x4313             ORRS     R3,R3,R2
   \   000000A2   0x9300             STR      R3,[SP, #+0]
   \   000000A4   0xE7E1             B        ??OSEventPendMulti_8
   \                     ??OSEventPendMulti_10: (+1)
   \   000000A6   0x686A             LDR      R2,[R5, #+4]
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD0DA             BEQ      ??OSEventPendMulti_7
   \   000000AC   0x9903             LDR      R1,[SP, #+12]
   \   000000AE   0x600A             STR      R2,[R1, #+0]
   \   000000B0   0x9903             LDR      R1,[SP, #+12]
   \   000000B2   0x1D09             ADDS     R1,R1,#+4
   \   000000B4   0x9103             STR      R1,[SP, #+12]
   \   000000B6   0x606F             STR      R7,[R5, #+4]
   \   000000B8   0x6025             STR      R5,[R4, #+0]
   \   000000BA   0x1D24             ADDS     R4,R4,#+4
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0x1C76             ADDS     R6,R6,#+1
   \   000000C0   0xE7D3             B        ??OSEventPendMulti_8
    448              }
    449          
    450              if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
   \                     ??OSEventPendMulti_9: (+1)
   \   000000C2   0x2901             CMP      R1,#+1
   \   000000C4   0xD109             BNE      ??OSEventPendMulti_13
    451                 *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
   \   000000C6   0x6027             STR      R7,[R4, #+0]
    452                  OS_EXIT_CRITICAL();
   \   000000C8   0x9801             LDR      R0,[SP, #+4]
   \   000000CA   0x.... 0x....      BL       OS_CPU_SR_Restore
    453                 *perr        =  OS_ERR_NONE;
   \   000000CE   0x980A             LDR      R0,[SP, #+40]
   \   000000D0   0x7007             STRB     R7,[R0, #+0]
    454                  return (events_rdy_nbr);
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0x0400             LSLS     R0,R0,#+16
   \   000000D6   0x0C00             LSRS     R0,R0,#+16
   \   000000D8   0xE081             B        ??OSEventPendMulti_3
    455              }
    456          /*$PAGE*/
    457                                                                  /* Otherwise, must wait until any event occurs */
    458              OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
    459                                         OS_STAT_MULTI;           /* ... pend on multiple events                 */
   \                     ??OSEventPendMulti_13: (+1)
   \   000000DA   0x....             LDR      R0,??DataTable7
   \   000000DC   0x6A00             LDR      R0,[R0, #+32]
   \   000000DE   0x2130             MOVS     R1,#+48
   \   000000E0   0x5C42             LDRB     R2,[R0, R1]
   \   000000E2   0x9B00             LDR      R3,[SP, #+0]
   \   000000E4   0x2180             MOVS     R1,#+128
   \   000000E6   0x4319             ORRS     R1,R1,R3
   \   000000E8   0x4311             ORRS     R1,R1,R2
   \   000000EA   0x2230             MOVS     R2,#+48
   \   000000EC   0x5481             STRB     R1,[R0, R2]
    460              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   000000EE   0x0038             MOVS     R0,R7
   \   000000F0   0x....             LDR      R1,??DataTable7
   \   000000F2   0x6A09             LDR      R1,[R1, #+32]
   \   000000F4   0x2231             MOVS     R2,#+49
   \   000000F6   0x5488             STRB     R0,[R1, R2]
    461              OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
   \   000000F8   0x4668             MOV      R0,SP
   \   000000FA   0x8A00             LDRH     R0,[R0, #+16]
   \   000000FC   0x....             LDR      R1,??DataTable7
   \   000000FE   0x6A09             LDR      R1,[R1, #+32]
   \   00000100   0x85C8             STRH     R0,[R1, #+46]
    462              OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
   \   00000102   0x9802             LDR      R0,[SP, #+8]
   \   00000104   0x.... 0x....      BL       OS_EventTaskWaitMulti
    463          
    464              OS_EXIT_CRITICAL();
   \   00000108   0x9801             LDR      R0,[SP, #+4]
   \   0000010A   0x.... 0x....      BL       OS_CPU_SR_Restore
    465              OS_Sched();                                         /* Find next highest priority task ready       */
   \   0000010E   0x.... 0x....      BL       OS_Sched
    466              OS_ENTER_CRITICAL();
   \   00000112   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000116   0x9001             STR      R0,[SP, #+4]
    467          
    468              switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
   \   00000118   0x....             LDR      R0,??DataTable7
   \   0000011A   0x6A00             LDR      R0,[R0, #+32]
   \   0000011C   0x0001             MOVS     R1,R0
   \   0000011E   0x311C             ADDS     R1,R1,#+28
   \   00000120   0x7D4A             LDRB     R2,[R1, #+21]
   \   00000122   0x2A00             CMP      R2,#+0
   \   00000124   0xD001             BEQ      ??OSEventPendMulti_14
   \   00000126   0x2A02             CMP      R2,#+2
   \   00000128   0xD10F             BNE      ??OSEventPendMulti_15
    469                  case OS_STAT_PEND_OK:
    470                  case OS_STAT_PEND_ABORT:
    471                       pevent = OSTCBCur->OSTCBEventPtr;
   \                     ??OSEventPendMulti_14: (+1)
   \   0000012A   0x680D             LDR      R5,[R1, #+0]
    472                       if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
   \   0000012C   0x2D00             CMP      R5,#+0
   \   0000012E   0xD004             BEQ      ??OSEventPendMulti_16
    473                          *pevents_rdy++ =  pevent;               /* ... return available event ...              */
   \   00000130   0x6025             STR      R5,[R4, #+0]
   \   00000132   0x1D24             ADDS     R4,R4,#+4
    474                          *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
   \   00000134   0x6027             STR      R7,[R4, #+0]
    475                            events_rdy_nbr++;
   \   00000136   0x1C76             ADDS     R6,R6,#+1
   \   00000138   0xE00A             B        ??OSEventPendMulti_17
    476          
    477                       } else {                                   /* Else NO event available, handle as timeout  */
    478                           OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
   \                     ??OSEventPendMulti_16: (+1)
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0x7548             STRB     R0,[R1, #+21]
    479                           OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \   0000013E   0x9902             LDR      R1,[SP, #+8]
   \   00000140   0x....             LDR      R0,??DataTable7
   \   00000142   0x6A00             LDR      R0,[R0, #+32]
   \   00000144   0x.... 0x....      BL       OS_EventTaskRemoveMulti
   \   00000148   0xE002             B        ??OSEventPendMulti_17
    480                       }
    481          			 break;
    482          
    483                  case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
    484                  default:                                        /* ... remove task from events' wait lists     */
    485                       OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \                     ??OSEventPendMulti_15: (+1)
   \   0000014A   0x9902             LDR      R1,[SP, #+8]
   \   0000014C   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    486                       break;
    487              }
    488          
    489              switch (OSTCBCur->OSTCBStatPend) {
   \                     ??OSEventPendMulti_17: (+1)
   \   00000150   0x....             LDR      R0,??DataTable7
   \   00000152   0x6A00             LDR      R0,[R0, #+32]
   \   00000154   0x3024             ADDS     R0,R0,#+36
   \   00000156   0x7B41             LDRB     R1,[R0, #+13]
   \   00000158   0x2900             CMP      R1,#+0
   \   0000015A   0xD002             BEQ      ??OSEventPendMulti_18
   \   0000015C   0x2902             CMP      R1,#+2
   \   0000015E   0xD01B             BEQ      ??OSEventPendMulti_19
   \   00000160   0xE020             B        ??OSEventPendMulti_20
    490                  case OS_STAT_PEND_OK:
    491                       switch (pevent->OSEventType) {             /* Return event's message                      */
   \                     ??OSEventPendMulti_18: (+1)
   \   00000162   0x7829             LDRB     R1,[R5, #+0]
   \   00000164   0x1E49             SUBS     R1,R1,#+1
   \   00000166   0x2901             CMP      R1,#+1
   \   00000168   0xD907             BLS      ??OSEventPendMulti_21
   \   0000016A   0x1E89             SUBS     R1,R1,#+2
   \   0000016C   0xD109             BNE      ??OSEventPendMulti_11
    492          #if (OS_SEM_EN > 0)
    493                           case OS_EVENT_TYPE_SEM:
    494                               *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
   \   0000016E   0x9803             LDR      R0,[SP, #+12]
   \   00000170   0x6007             STR      R7,[R0, #+0]
    495                                break;
    496          #endif
    497          
    498          #if ((OS_MBOX_EN > 0) ||                 \
    499              ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
    500                           case OS_EVENT_TYPE_MBOX:
    501                           case OS_EVENT_TYPE_Q:
    502                               *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
    503                                break;
    504          #endif
    505          
    506                           case OS_EVENT_TYPE_MUTEX:                                       
    507                           case OS_EVENT_TYPE_FLAG:
    508                           default:           
    509                                OS_EXIT_CRITICAL();
    510                               *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
    511                               *perr        =  OS_ERR_EVENT_TYPE;
    512                                return (events_rdy_nbr);
    513                       }
    514                      *perr = OS_ERR_NONE;
   \                     ??OSEventPendMulti_22: (+1)
   \   00000172   0x0038             MOVS     R0,R7
   \   00000174   0x990A             LDR      R1,[SP, #+40]
   \   00000176   0x7008             STRB     R0,[R1, #+0]
    515                       break;
   \   00000178   0xE019             B        ??OSEventPendMulti_23
   \                     ??OSEventPendMulti_21: (+1)
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x9903             LDR      R1,[SP, #+12]
   \   0000017E   0x6008             STR      R0,[R1, #+0]
   \   00000180   0xE7F7             B        ??OSEventPendMulti_22
   \                     ??OSEventPendMulti_11: (+1)
   \   00000182   0x9801             LDR      R0,[SP, #+4]
   \   00000184   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000188   0x6027             STR      R7,[R4, #+0]
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0x990A             LDR      R1,[SP, #+40]
   \   0000018E   0x7008             STRB     R0,[R1, #+0]
   \   00000190   0x0030             MOVS     R0,R6
   \   00000192   0x0400             LSLS     R0,R0,#+16
   \   00000194   0x0C00             LSRS     R0,R0,#+16
   \   00000196   0xE022             B        ??OSEventPendMulti_3
    516          
    517                  case OS_STAT_PEND_ABORT:
    518                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
   \                     ??OSEventPendMulti_19: (+1)
   \   00000198   0x9803             LDR      R0,[SP, #+12]
   \   0000019A   0x6007             STR      R7,[R0, #+0]
    519                      *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
   \   0000019C   0x200E             MOVS     R0,#+14
   \   0000019E   0x990A             LDR      R1,[SP, #+40]
   \   000001A0   0x7008             STRB     R0,[R1, #+0]
    520                       break;
   \   000001A2   0xE004             B        ??OSEventPendMulti_23
    521                                                                  
    522                  case OS_STAT_PEND_TO:                                                
    523                  default:        
    524                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
   \                     ??OSEventPendMulti_20: (+1)
   \   000001A4   0x9803             LDR      R0,[SP, #+12]
   \   000001A6   0x6007             STR      R7,[R0, #+0]
    525                      *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
   \   000001A8   0x200A             MOVS     R0,#+10
   \   000001AA   0x990A             LDR      R1,[SP, #+40]
   \   000001AC   0x7008             STRB     R0,[R1, #+0]
    526                       break;
    527              }
    528          
    529              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
   \                     ??OSEventPendMulti_23: (+1)
   \   000001AE   0x0038             MOVS     R0,R7
   \   000001B0   0x....             LDR      R1,??DataTable7
   \   000001B2   0x6A09             LDR      R1,[R1, #+32]
   \   000001B4   0x2230             MOVS     R2,#+48
   \   000001B6   0x5488             STRB     R0,[R1, R2]
    530              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
   \   000001B8   0x....             LDR      R1,??DataTable7
   \   000001BA   0x6A09             LDR      R1,[R1, #+32]
   \   000001BC   0x2231             MOVS     R2,#+49
   \   000001BE   0x5488             STRB     R0,[R1, R2]
    531              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
   \   000001C0   0x....             LDR      R0,??DataTable7
   \   000001C2   0x6A00             LDR      R0,[R0, #+32]
   \   000001C4   0x61C7             STR      R7,[R0, #+28]
    532              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   000001C6   0x....             LDR      R0,??DataTable7
   \   000001C8   0x6A00             LDR      R0,[R0, #+32]
   \   000001CA   0x6207             STR      R7,[R0, #+32]
    533              OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
   \   000001CC   0x....             LDR      R0,??DataTable7
   \   000001CE   0x6A00             LDR      R0,[R0, #+32]
   \   000001D0   0x6247             STR      R7,[R0, #+36]
    534              OS_EXIT_CRITICAL();
   \   000001D2   0x9801             LDR      R0,[SP, #+4]
   \   000001D4   0x.... 0x....      BL       OS_CPU_SR_Restore
    535          
    536              return (events_rdy_nbr);
   \   000001D8   0x0030             MOVS     R0,R6
   \   000001DA   0x0400             LSLS     R0,R0,#+16
   \   000001DC   0x0C00             LSRS     R0,R0,#+16
   \                     ??OSEventPendMulti_3: (+1)
   \   000001DE   0xB005             ADD      SP,SP,#+20
   \   000001E0   0xBCF0             POP      {R4-R7}
   \   000001E2   0xBC08             POP      {R3}
   \   000001E4   0x4718             BX       R3               ;; return
    537          }
    538          #endif
    539          
    540          /*$PAGE*/
    541          /*
    542          *********************************************************************************************************
    543          *                                             INITIALIZATION
    544          *
    545          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    546          *              creating any uC/OS-II object and, prior to calling OSStart().
    547          *
    548          * Arguments  : none
    549          *
    550          * Returns    : none
    551          *********************************************************************************************************
    552          */
    553          

   \                                 In section .text, align 2, keep-with-next
    554          void  OSInit (void)
    555          {
   \                     OSInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    556              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \   00000002   0x.... 0x....      BL       OSInitHookBegin
    557          
    558              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \   00000006   0x.... 0x....      BL       OS_InitMisc
    559          
    560              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \   0000000A   0x.... 0x....      BL       OS_InitRdyList
    561          
    562              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \   0000000E   0x.... 0x....      BL       OS_InitTCBList
    563          
    564              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \   00000012   0x.... 0x....      BL       OS_InitEventList
    565          
    566          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    567              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \   00000016   0x.... 0x....      BL       OS_FlagInit
    568          #endif
    569          
    570          #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    571              OS_MemInit();                                                /* Initialize the memory manager            */
    572          #endif
    573          
    574          #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    575              OS_QInit();                                                  /* Initialize the message queue structures  */
    576          #endif
    577          
    578              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \   0000001A   0x.... 0x....      BL       OS_InitTaskIdle
    579          #if OS_TASK_STAT_EN > 0
    580              OS_InitTaskStat();                                           /* Create the Statistic Task                */
   \   0000001E   0x.... 0x....      BL       OS_InitTaskStat
    581          #endif
    582          
    583          #if OS_TMR_EN > 0
    584              OSTmr_Init();                                                /* Initialize the Timer Manager             */
    585          #endif
    586          
    587              OSInitHookEnd();                                             /* Call port specific init. code            */
   \   00000022   0x.... 0x....      BL       OSInitHookEnd
    588          
    589          #if OS_DEBUG_EN > 0
    590              OSDebugInit();
   \   00000026   0x.... 0x....      BL       OSDebugInit
    591          #endif
    592          }
   \   0000002A   0xBC09             POP      {R0,R3}
   \   0000002C   0x4718             BX       R3               ;; return
    593          /*$PAGE*/
    594          /*
    595          *********************************************************************************************************
    596          *                                              ENTER ISR
    597          *
    598          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    599          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    600          *              only perform rescheduling at the last nested ISR.
    601          *
    602          * Arguments  : none
    603          *
    604          * Returns    : none
    605          *
    606          * Notes      : 1) This function should be called ith interrupts already disabled
    607          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    608          *                 OSIntNesting has been declared 'global'.
    609          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    610          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    611          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    612          *                 end of the ISR.
    613          *              5) You are allowed to nest interrupts up to 255 levels deep.
    614          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    615          *                 OSIntEnter() is always called with interrupts disabled.
    616          *********************************************************************************************************
    617          */
    618          

   \                                 In section .text, align 2, keep-with-next
    619          void  OSIntEnter (void)
    620          {
    621              if (OSRunning == OS_TRUE) {
   \                     OSIntEnter: (+1)
   \   00000000   0x....             LDR      R0,??DataTable15
   \   00000002   0x79C1             LDRB     R1,[R0, #+7]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD104             BNE      ??OSIntEnter_0
    622                  if (OSIntNesting < 255u) {
   \   00000008   0x7881             LDRB     R1,[R0, #+2]
   \   0000000A   0x29FF             CMP      R1,#+255
   \   0000000C   0xD001             BEQ      ??OSIntEnter_0
    623                      OSIntNesting++;                      /* Increment ISR nesting level                        */
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x7081             STRB     R1,[R0, #+2]
    624                  }
    625              }
    626          }
   \                     ??OSIntEnter_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    627          /*$PAGE*/
    628          /*
    629          *********************************************************************************************************
    630          *                                               EXIT ISR
    631          *
    632          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
    633          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    634          *              a new, high-priority task, is ready to run.
    635          *
    636          * Arguments  : none
    637          *
    638          * Returns    : none
    639          *
    640          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    641          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    642          *                 end of the ISR.
    643          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    644          *********************************************************************************************************
    645          */
    646          

   \                                 In section .text, align 2, keep-with-next
    647          void  OSIntExit (void)
    648          {
   \                     OSIntExit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    649          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    650              OS_CPU_SR  cpu_sr = 0;
    651          #endif
    652          
    653          
    654          
    655              if (OSRunning == OS_TRUE) {
   \   00000002   0x....             LDR      R4,??DataTable7
   \   00000004   0x79E0             LDRB     R0,[R4, #+7]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD121             BNE      ??OSIntExit_0
    656                  OS_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000E   0x0005             MOVS     R5,R0
    657                  if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
   \   00000010   0x78A0             LDRB     R0,[R4, #+2]
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xD001             BEQ      ??OSIntExit_1
    658                      OSIntNesting--;
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x70A0             STRB     R0,[R4, #+2]
    659                  }
    660                  if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    661                      if (OSLockNesting == 0) {                      /* ... and not locked.                      */
   \                     ??OSIntExit_1: (+1)
   \   0000001A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001C   0x78E1             LDRB     R1,[R4, #+3]
   \   0000001E   0x4301             ORRS     R1,R1,R0
   \   00000020   0xD112             BNE      ??OSIntExit_2
    662                          OS_SchedNew();
   \   00000022   0x.... 0x....      BL       OS_SchedNew
    663                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \   00000026   0x7960             LDRB     R0,[R4, #+5]
   \   00000028   0x0001             MOVS     R1,R0
   \   0000002A   0x7922             LDRB     R2,[R4, #+4]
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD00B             BEQ      ??OSIntExit_2
    664                              OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
   \   00000030   0x....             LDR      R1,??DataTable15_1
   \   00000032   0x0080             LSLS     R0,R0,#+2
   \   00000034   0x5808             LDR      R0,[R1, R0]
   \   00000036   0x62A0             STR      R0,[R4, #+40]
    665          #if OS_TASK_PROFILE_EN > 0
    666                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \   00000038   0x6B81             LDR      R1,[R0, #+56]
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
   \   0000003C   0x6381             STR      R1,[R0, #+56]
    667          #endif
    668                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
   \   0000003E   0x6920             LDR      R0,[R4, #+16]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x6120             STR      R0,[R4, #+16]
    669                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \   00000044   0x.... 0x....      BL       OSIntCtxSw
    670                          }
    671                      }
    672                  }
    673                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    674              }
    675          }
   \                     ??OSIntExit_0: (+1)
   \   0000004E   0xBC31             POP      {R0,R4,R5}
   \   00000050   0xBC08             POP      {R3}
   \   00000052   0x4718             BX       R3               ;; return
    676          /*$PAGE*/
    677          /*
    678          *********************************************************************************************************
    679          *                                          PREVENT SCHEDULING
    680          *
    681          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    682          *              to prevent context switches until you are ready to permit context switching.
    683          *
    684          * Arguments  : none
    685          *
    686          * Returns    : none
    687          *
    688          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    689          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    690          *********************************************************************************************************
    691          */
    692          
    693          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    694          void  OSSchedLock (void)
    695          {
   \                     OSSchedLock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    696          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    697              OS_CPU_SR  cpu_sr = 0;
    698          #endif
    699          
    700          
    701          
    702              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \   00000002   0x....             LDR      R4,??DataTable15
   \   00000004   0x79E0             LDRB     R0,[R4, #+7]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE      ??OSSchedLock_0
    703                  OS_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       OS_CPU_SR_Save
    704                  if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
   \   0000000E   0x78A1             LDRB     R1,[R4, #+2]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD104             BNE      ??OSSchedLock_1
    705                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \   00000014   0x78E1             LDRB     R1,[R4, #+3]
   \   00000016   0x29FF             CMP      R1,#+255
   \   00000018   0xD001             BEQ      ??OSSchedLock_1
    706                          OSLockNesting++;                 /* Increment lock nesting level                       */
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x70E1             STRB     R1,[R4, #+3]
    707                      }
    708                  }
    709                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1: (+1)
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    710              }
    711          }
   \                     ??OSSchedLock_0: (+1)
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0xBC08             POP      {R3}
   \   00000026   0x4718             BX       R3               ;; return
    712          #endif
    713          
    714          /*$PAGE*/
    715          /*
    716          *********************************************************************************************************
    717          *                                          ENABLE SCHEDULING
    718          *
    719          * Description: This function is used to re-allow rescheduling.
    720          *
    721          * Arguments  : none
    722          *
    723          * Returns    : none
    724          *
    725          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    726          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    727          *********************************************************************************************************
    728          */
    729          
    730          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    731          void  OSSchedUnlock (void)
    732          {
   \                     OSSchedUnlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    733          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    734              OS_CPU_SR  cpu_sr = 0;
    735          #endif
    736          
    737          
    738          
    739              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \   00000002   0x....             LDR      R4,??DataTable15
   \   00000004   0x79E0             LDRB     R0,[R4, #+7]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD118             BNE      ??OSSchedUnlock_0
    740                  OS_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       OS_CPU_SR_Save
    741                  if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
   \   0000000E   0x78E1             LDRB     R1,[R4, #+3]
   \   00000010   0x000A             MOVS     R2,R1
   \   00000012   0xD011             BEQ      ??OSSchedUnlock_1
    742                      OSLockNesting--;                               /* Decrement lock nesting level             */
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x70E1             STRB     R1,[R4, #+3]
    743                      if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
   \   00000018   0x0609             LSLS     R1,R1,#+24
   \   0000001A   0xD10A             BNE      ??OSSchedUnlock_2
    744                          if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
   \   0000001C   0x78A1             LDRB     R1,[R4, #+2]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE      ??OSSchedUnlock_3
    745                              OS_EXIT_CRITICAL();
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
    746                              OS_Sched();                            /* See if a HPT is ready                    */
   \   00000026   0x.... 0x....      BL       OS_Sched
   \   0000002A   0xE007             B        ??OSSchedUnlock_0
    747                          } else {
    748                              OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_3: (+1)
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000030   0xE004             B        ??OSSchedUnlock_0
    749                          }
    750                      } else {
    751                          OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_2: (+1)
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000036   0xE001             B        ??OSSchedUnlock_0
    752                      }
    753                  } else {
    754                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1: (+1)
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
    755                  }
    756              }
    757          }
   \                     ??OSSchedUnlock_0: (+1)
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0xBC08             POP      {R3}
   \   00000040   0x4718             BX       R3               ;; return
    758          #endif
    759          
    760          /*$PAGE*/
    761          /*
    762          *********************************************************************************************************
    763          *                                          START MULTITASKING
    764          *
    765          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    766          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    767          *              and you MUST have created at least one task.
    768          *
    769          * Arguments  : none
    770          *
    771          * Returns    : none
    772          *
    773          * Note       : OSStartHighRdy() MUST:
    774          *                 a) Call OSTaskSwHook() then,
    775          *                 b) Set OSRunning to OS_TRUE.
    776          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    777          *                 d_ Execute the task.
    778          *********************************************************************************************************
    779          */
    780          

   \                                 In section .text, align 2, keep-with-next
    781          void  OSStart (void)
    782          {
   \                     OSStart: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    783              if (OSRunning == OS_FALSE) {
   \   00000002   0x....             LDR      R4,??DataTable15
   \   00000004   0x79E0             LDRB     R0,[R4, #+7]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD10A             BNE      ??OSStart_0
    784                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \   0000000A   0x.... 0x....      BL       OS_SchedNew
    785                  OSPrioCur     = OSPrioHighRdy;
   \   0000000E   0x7960             LDRB     R0,[R4, #+5]
   \   00000010   0x7120             STRB     R0,[R4, #+4]
    786                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \   00000012   0x....             LDR      R1,??DataTable15_1
   \   00000014   0x0080             LSLS     R0,R0,#+2
   \   00000016   0x5808             LDR      R0,[R1, R0]
   \   00000018   0x62A0             STR      R0,[R4, #+40]
    787                  OSTCBCur      = OSTCBHighRdy;
   \   0000001A   0x6220             STR      R0,[R4, #+32]
    788                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \   0000001C   0x.... 0x....      BL       OSStartHighRdy
    789              }
    790          }
   \                     ??OSStart_0: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0xBC08             POP      {R3}
   \   00000024   0x4718             BX       R3               ;; return
    791          /*$PAGE*/
    792          /*
    793          *********************************************************************************************************
    794          *                                        STATISTICS INITIALIZATION
    795          *
    796          * Description: This function is called by your application to establish CPU usage by first determining
    797          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    798          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    799          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    800          *              determined by:
    801          *
    802          *                                             OSIdleCtr
    803          *                 CPU Usage (%) = 100 * (1 - ------------)
    804          *                                            OSIdleCtrMax
    805          *
    806          * Arguments  : none
    807          *
    808          * Returns    : none
    809          *********************************************************************************************************
    810          */
    811          
    812          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    813          void  OSStatInit (void)
    814          {
   \                     OSStatInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    815          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    816              OS_CPU_SR  cpu_sr = 0;
    817          #endif
    818          
    819          
    820          
    821              OSTimeDly(2);                                /* Synchronize with clock tick                        */
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       OSTimeDly
    822              OS_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
    823              OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
   \   0000000C   0x....             LDR      R4,??DataTable15
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x61E1             STR      R1,[R4, #+28]
    824              OS_EXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    825              OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
   \   00000016   0x2064             MOVS     R0,#+100
   \   00000018   0x.... 0x....      BL       OSTimeDly
    826              OS_ENTER_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
    827              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
   \   00000020   0x69E1             LDR      R1,[R4, #+28]
   \   00000022   0x6161             STR      R1,[R4, #+20]
    828              OSStatRdy    = OS_TRUE;
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x7061             STRB     R1,[R4, #+1]
    829              OS_EXIT_CRITICAL();
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Restore
    830          }
   \   0000002C   0xBC10             POP      {R4}
   \   0000002E   0xBC08             POP      {R3}
   \   00000030   0x4718             BX       R3               ;; return
    831          #endif
    832          /*$PAGE*/
    833          /*
    834          *********************************************************************************************************
    835          *                                         PROCESS SYSTEM TICK
    836          *
    837          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    838          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    839          *              called by a high priority task.
    840          *
    841          * Arguments  : none
    842          *
    843          * Returns    : none
    844          *********************************************************************************************************
    845          */
    846          

   \                                 In section .text, align 2, keep-with-next
    847          void  OSTimeTick (void)
    848          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    849              OS_TCB    *ptcb;
    850          #if OS_TICK_STEP_EN > 0
    851              BOOLEAN    step;
    852          #endif
    853          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    854              OS_CPU_SR  cpu_sr = 0;
    855          #endif
    856          
    857          
    858          
    859          #if OS_TIME_TICK_HOOK_EN > 0
    860              OSTimeTickHook();                                      /* Call user definable hook                     */
   \   00000002   0x.... 0x....      BL       OSTimeTickHook
    861          #endif
    862          #if OS_TIME_GET_SET_EN > 0
    863              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
    864              OSTime++;
   \   0000000A   0x....             LDR      R4,??DataTable15
   \   0000000C   0x6B21             LDR      R1,[R4, #+48]
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x6321             STR      R1,[R4, #+48]
    865              OS_EXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    866          #endif
    867              if (OSRunning == OS_TRUE) {
   \   00000016   0x79E0             LDRB     R0,[R4, #+7]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD141             BNE      ??OSTimeTick_0
    868          #if OS_TICK_STEP_EN > 0
    869                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \   0000001C   0x7A60             LDRB     R0,[R4, #+9]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ      ??OSTimeTick_1
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD005             BEQ      ??OSTimeTick_2
   \   00000026   0xD302             BCC      ??OSTimeTick_3
   \   00000028   0xE007             B        ??OSTimeTick_4
    870                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    871                           step = OS_TRUE;
   \                     ??OSTimeTick_1: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
    872                           break;
   \   0000002C   0xE008             B        ??OSTimeTick_5
    873          
    874                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    875                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
   \                     ??OSTimeTick_3: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
    876                           break;
   \   00000030   0xE006             B        ??OSTimeTick_5
    877          
    878                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    879                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
   \                     ??OSTimeTick_2: (+1)
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x0008             MOVS     R0,R1
    880                           OSTickStepState = OS_TICK_STEP_WAIT;
   \   00000036   0x7261             STRB     R1,[R4, #+9]
    881                           break;
   \   00000038   0xE002             B        ??OSTimeTick_5
    882          
    883                      default:                                       /* Invalid case, correct situation              */
    884                           step            = OS_TRUE;
   \                     ??OSTimeTick_4: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
    885                           OSTickStepState = OS_TICK_STEP_DIS;
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x7261             STRB     R1,[R4, #+9]
    886                           break;
    887                  }
    888                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
   \                     ??OSTimeTick_5: (+1)
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD02D             BEQ      ??OSTimeTick_0
    889                      return;
    890                  }
    891          #endif
    892                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \   00000044   0x6AE5             LDR      R5,[R4, #+44]
   \   00000046   0xE013             B        ??OSTimeTick_6
    893                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
    894                      OS_ENTER_CRITICAL();
    895                      if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
    896                          if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
    897                                                                     /* Check for timeout                            */
    898                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    899                                  ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
    900                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
    901                              } else {
    902                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \                     ??OSTimeTick_7: (+1)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x7771             STRB     R1,[R6, #+29]
    903                              }
    904          
    905                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \                     ??OSTimeTick_8: (+1)
   \   0000004C   0x7F31             LDRB     R1,[R6, #+28]
   \   0000004E   0x0709             LSLS     R1,R1,#+28
   \   00000050   0xD40B             BMI      ??OSTimeTick_9
    906                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \   00000052   0x0029             MOVS     R1,R5
   \   00000054   0x3134             ADDS     R1,R1,#+52
   \   00000056   0x79A2             LDRB     R2,[R4, #+6]
   \   00000058   0x788B             LDRB     R3,[R1, #+2]
   \   0000005A   0x4313             ORRS     R3,R3,R2
   \   0000005C   0x71A3             STRB     R3,[R4, #+6]
    907                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000005E   0x780A             LDRB     R2,[R1, #+0]
   \   00000060   0x18A2             ADDS     R2,R4,R2
   \   00000062   0x7B13             LDRB     R3,[R2, #+12]
   \   00000064   0x7849             LDRB     R1,[R1, #+1]
   \   00000066   0x4319             ORRS     R1,R1,R3
   \   00000068   0x7311             STRB     R1,[R2, #+12]
    908                              }
    909                          }
    910                      }
    911                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_9: (+1)
   \   0000006A   0x6835             LDR      R5,[R6, #+0]
    912                      OS_EXIT_CRITICAL();
   \   0000006C   0x.... 0x....      BL       OS_CPU_SR_Restore
   \                     ??OSTimeTick_6: (+1)
   \   00000070   0x002E             MOVS     R6,R5
   \   00000072   0x3614             ADDS     R6,R6,#+20
   \   00000074   0x7FB0             LDRB     R0,[R6, #+30]
   \   00000076   0x281F             CMP      R0,#+31
   \   00000078   0xD012             BEQ      ??OSTimeTick_0
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000007E   0x8B71             LDRH     R1,[R6, #+26]
   \   00000080   0x000A             MOVS     R2,R1
   \   00000082   0xD0F2             BEQ      ??OSTimeTick_9
   \   00000084   0x1E49             SUBS     R1,R1,#+1
   \   00000086   0x8371             STRH     R1,[R6, #+26]
   \   00000088   0x0409             LSLS     R1,R1,#+16
   \   0000008A   0xD1EE             BNE      ??OSTimeTick_9
   \   0000008C   0x7F31             LDRB     R1,[R6, #+28]
   \   0000008E   0x2237             MOVS     R2,#+55
   \   00000090   0x4211             TST      R1,R2
   \   00000092   0xD0D9             BEQ      ??OSTimeTick_7
   \   00000094   0x22C8             MOVS     R2,#+200
   \   00000096   0x400A             ANDS     R2,R2,R1
   \   00000098   0x7732             STRB     R2,[R6, #+28]
   \   0000009A   0x2101             MOVS     R1,#+1
   \   0000009C   0x7771             STRB     R1,[R6, #+29]
   \   0000009E   0xE7D5             B        ??OSTimeTick_8
    913                  }
    914              }
    915          }
   \                     ??OSTimeTick_0: (+1)
   \   000000A0   0xBC70             POP      {R4-R6}
   \   000000A2   0xBC08             POP      {R3}
   \   000000A4   0x4718             BX       R3               ;; return
    916          
    917          /*$PAGE*/
    918          /*
    919          *********************************************************************************************************
    920          *                                             GET VERSION
    921          *
    922          * Description: This function is used to return the version number of uC/OS-II.  The returned value
    923          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
    924          *              would be returned as 200.
    925          *
    926          * Arguments  : none
    927          *
    928          * Returns    : the version number of uC/OS-II multiplied by 100.
    929          *********************************************************************************************************
    930          */
    931          

   \                                 In section .text, align 2, keep-with-next
    932          INT16U  OSVersion (void)
    933          {
    934              return (OS_VERSION);
   \                     OSVersion: (+1)
   \   00000000   0x208F             MOVS     R0,#+143
   \   00000002   0x0040             LSLS     R0,R0,#+1        ;; #+286
   \   00000004   0x4770             BX       LR               ;; return
    935          }
    936          
    937          /*$PAGE*/
    938          /*
    939          *********************************************************************************************************
    940          *                                            DUMMY FUNCTION
    941          *
    942          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    943          *
    944          * Arguments  : none
    945          *
    946          * Returns    : none
    947          *********************************************************************************************************
    948          */
    949          
    950          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    951          void  OS_Dummy (void)
    952          {
    953          }
   \                     OS_Dummy: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    954          #endif
    955          
    956          /*$PAGE*/
    957          /*
    958          *********************************************************************************************************
    959          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
    960          *
    961          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
    962          *              waiting for an event to occur.
    963          *
    964          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
    965          *
    966          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
    967          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
    968          *                          service functions.
    969          *
    970          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
    971          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
    972          *
    973          *              pend_stat   is used to indicate the readied task's pending status:
    974          *
    975          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
    976          *                                               an abort.
    977          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
    978          *
    979          * Returns    : none
    980          *
    981          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    982          *********************************************************************************************************
    983          */
    984          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
    985          INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
    986          {
   \                     OS_EventTaskRdy: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    987              OS_TCB  *ptcb;
    988              INT8U    y;
    989              INT8U    x;
    990              INT8U    prio;
    991          #if OS_LOWEST_PRIO > 63
    992              INT16U  *ptbl;
    993          #endif
    994          
    995          
    996          #if OS_LOWEST_PRIO <= 63
    997              y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
   \   00000004   0x....             LDR      R2,??DataTable21
   \   00000006   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000008   0x5C10             LDRB     R0,[R2, R0]
    998              x    = OSUnMapTbl[pevent->OSEventTbl[y]];
    999              prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
   \   0000000A   0x00C5             LSLS     R5,R0,#+3
   \   0000000C   0x1826             ADDS     R6,R4,R0
   \   0000000E   0x7AF6             LDRB     R6,[R6, #+11]
   \   00000010   0x5D92             LDRB     R2,[R2, R6]
   \   00000012   0x18AE             ADDS     R6,R5,R2
   1000          #else
   1001              if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
   1002                  y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
   1003              } else {
   1004                  y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
   1005              }
   1006              ptbl = &pevent->OSEventTbl[y];
   1007              if ((*ptbl & 0xFF) != 0) {
   1008                  x = OSUnMapTbl[*ptbl & 0xFF];
   1009              } else {
   1010                  x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
   1011              }
   1012              prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
   1013          #endif
   1014          
   1015              ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
   \   00000014   0x....             LDR      R2,??DataTable15_1
   \   00000016   0x0636             LSLS     R6,R6,#+24
   \   00000018   0x0E36             LSRS     R6,R6,#+24
   \   0000001A   0x00B5             LSLS     R5,R6,#+2
   \   0000001C   0x5957             LDR      R7,[R2, R5]
   1016              ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
   \   0000001E   0x003D             MOVS     R5,R7
   \   00000020   0x351C             ADDS     R5,R5,#+28
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x826A             STRH     R2,[R5, #+18]
   1017          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
   1018              ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
   \   00000026   0x60A9             STR      R1,[R5, #+8]
   1019          #else
   1020              pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
   1021          #endif
   1022              ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
   \   00000028   0x7D29             LDRB     R1,[R5, #+20]
   \   0000002A   0x466A             MOV      R2,SP
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0x4391             BICS     R1,R1,R2
   \   00000030   0x7529             STRB     R1,[R5, #+20]
   1023              ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
   \   00000032   0x756B             STRB     R3,[R5, #+21]
   1024                                                                  /* See if task is ready (could be susp'd)      */
   1025              if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
   \   00000034   0x7D29             LDRB     R1,[R5, #+20]
   \   00000036   0x0709             LSLS     R1,R1,#+28
   \   00000038   0xD409             BMI      ??OS_EventTaskRdy_0
   1026                  OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
   \   0000003A   0x....             LDR      R1,??DataTable15
   \   0000003C   0x798A             LDRB     R2,[R1, #+6]
   \   0000003E   0x7EAB             LDRB     R3,[R5, #+26]
   \   00000040   0x4313             ORRS     R3,R3,R2
   \   00000042   0x718B             STRB     R3,[R1, #+6]
   1027                  OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
   \   00000044   0x1808             ADDS     R0,R1,R0
   \   00000046   0x7B01             LDRB     R1,[R0, #+12]
   \   00000048   0x7E6A             LDRB     R2,[R5, #+25]
   \   0000004A   0x430A             ORRS     R2,R2,R1
   \   0000004C   0x7302             STRB     R2,[R0, #+12]
   1028              }
   1029          
   1030              OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
   \                     ??OS_EventTaskRdy_0: (+1)
   \   0000004E   0x0021             MOVS     R1,R4
   \   00000050   0x0038             MOVS     R0,R7
   \   00000052   0x.... 0x....      BL       OS_EventTaskRemove
   1031          #if (OS_EVENT_MULTI_EN > 0)
   1032              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
   \   00000056   0x6869             LDR      R1,[R5, #+4]
   \   00000058   0x2900             CMP      R1,#+0
   \   0000005A   0xD003             BEQ      ??OS_EventTaskRdy_1
   1033                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0x.... 0x....      BL       OS_EventTaskRemoveMulti
   1034                  ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
   \   00000062   0x602C             STR      R4,[R5, #+0]
   1035              }
   1036          #endif
   1037          
   1038              return (prio);
   \                     ??OS_EventTaskRdy_1: (+1)
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0xBCF2             POP      {R1,R4-R7}
   \   00000068   0xBC08             POP      {R3}
   \   0000006A   0x4718             BX       R3               ;; return
   1039          }
   1040          #endif
   1041          /*$PAGE*/
   1042          /*
   1043          *********************************************************************************************************
   1044          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
   1045          *
   1046          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
   1047          *              not occurred.
   1048          *
   1049          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
   1050          *
   1051          * Returns    : none
   1052          *
   1053          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1054          *********************************************************************************************************
   1055          */
   1056          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1057          void  OS_EventTaskWait (OS_EVENT *pevent)
   1058          {
   \                     OS_EventTaskWait: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1059              INT8U  y;
   1060          
   1061          
   1062              OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
   \   00000002   0x....             LDR      R1,??DataTable15
   \   00000004   0x6A0A             LDR      R2,[R1, #+32]
   \   00000006   0x61D0             STR      R0,[R2, #+28]
   1063          
   1064              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
   \   00000008   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000A   0x3234             ADDS     R2,R2,#+52
   \   0000000C   0x7813             LDRB     R3,[R2, #+0]
   \   0000000E   0x18C3             ADDS     R3,R0,R3
   \   00000010   0x7ADC             LDRB     R4,[R3, #+11]
   \   00000012   0x7852             LDRB     R2,[R2, #+1]
   \   00000014   0x4322             ORRS     R2,R2,R4
   \   00000016   0x72DA             STRB     R2,[R3, #+11]
   1065              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000018   0x7A82             LDRB     R2,[R0, #+10]
   \   0000001A   0x6A0B             LDR      R3,[R1, #+32]
   \   0000001C   0x2436             MOVS     R4,#+54
   \   0000001E   0x5D1B             LDRB     R3,[R3, R4]
   \   00000020   0x4313             ORRS     R3,R3,R2
   \   00000022   0x7283             STRB     R3,[R0, #+10]
   1066          
   1067              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   00000024   0x6A08             LDR      R0,[R1, #+32]
   \   00000026   0x3034             ADDS     R0,R0,#+52
   \   00000028   0x7802             LDRB     R2,[R0, #+0]
   1068              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   0000002A   0x188A             ADDS     R2,R1,R2
   \   0000002C   0x7B13             LDRB     R3,[R2, #+12]
   \   0000002E   0x7844             LDRB     R4,[R0, #+1]
   \   00000030   0x43A3             BICS     R3,R3,R4
   \   00000032   0x7313             STRB     R3,[R2, #+12]
   1069              if (OSRdyTbl[y] == 0) {
   \   00000034   0xD103             BNE      ??OS_EventTaskWait_0
   1070                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   00000036   0x798A             LDRB     R2,[R1, #+6]
   \   00000038   0x7880             LDRB     R0,[R0, #+2]
   \   0000003A   0x4382             BICS     R2,R2,R0
   \   0000003C   0x718A             STRB     R2,[R1, #+6]
   1071              }
   1072          }
   \                     ??OS_EventTaskWait_0: (+1)
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return
   1073          #endif
   1074          /*$PAGE*/
   1075          /*
   1076          *********************************************************************************************************
   1077          *                          MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
   1078          *
   1079          * Description: This function is called by other uC/OS-II services to suspend a task because any one of
   1080          *              multiple events has not occurred.
   1081          *
   1082          * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for 
   1083          *                               which the task will be waiting for.
   1084          *
   1085          * Returns    : none.
   1086          *
   1087          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1088          *********************************************************************************************************
   1089          */
   1090          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1091          void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
   1092          {
   \                     OS_EventTaskWaitMulti: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1093              OS_EVENT **pevents;
   1094              OS_EVENT  *pevent;
   1095              INT8U      y;
   1096          
   1097          
   1098              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
   \   00000002   0x....             LDR      R1,??DataTable15
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6A0B             LDR      R3,[R1, #+32]
   \   00000008   0x61DA             STR      R2,[R3, #+28]
   1099              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
   \   0000000A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000C   0x6210             STR      R0,[R2, #+32]
   1100          
   1101              pevents =  pevents_wait;
   1102              pevent  = *pevents;
   \   0000000E   0x6803             LDR      R3,[R0, #+0]
   \   00000010   0xE00B             B        ??OS_EventTaskWaitMulti_0
   1103              while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
   1104                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
   \                     ??OS_EventTaskWaitMulti_1: (+1)
   \   00000012   0x195C             ADDS     R4,R3,R5
   \   00000014   0x7AE5             LDRB     R5,[R4, #+11]
   \   00000016   0x432A             ORRS     R2,R2,R5
   \   00000018   0x72E2             STRB     R2,[R4, #+11]
   1105                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   0000001A   0x7A9A             LDRB     R2,[R3, #+10]
   \   0000001C   0x6A0C             LDR      R4,[R1, #+32]
   \   0000001E   0x2536             MOVS     R5,#+54
   \   00000020   0x5D64             LDRB     R4,[R4, R5]
   \   00000022   0x4314             ORRS     R4,R4,R2
   \   00000024   0x729C             STRB     R4,[R3, #+10]
   1106                  pevents++;
   \   00000026   0x1D00             ADDS     R0,R0,#+4
   1107                  pevent = *pevents;
   \   00000028   0x6803             LDR      R3,[R0, #+0]
   1108              }
   \                     ??OS_EventTaskWaitMulti_0: (+1)
   \   0000002A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002C   0x0014             MOVS     R4,R2
   \   0000002E   0x3434             ADDS     R4,R4,#+52
   \   00000030   0x7862             LDRB     R2,[R4, #+1]
   \   00000032   0x7825             LDRB     R5,[R4, #+0]
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD1EC             BNE      ??OS_EventTaskWaitMulti_1
   1109          
   1110              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   1111              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   00000038   0x1948             ADDS     R0,R1,R5
   \   0000003A   0x7B03             LDRB     R3,[R0, #+12]
   \   0000003C   0x4393             BICS     R3,R3,R2
   \   0000003E   0x7303             STRB     R3,[R0, #+12]
   1112              if (OSRdyTbl[y] == 0) {
   \   00000040   0xD103             BNE      ??OS_EventTaskWaitMulti_2
   1113                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   00000042   0x7988             LDRB     R0,[R1, #+6]
   \   00000044   0x78A2             LDRB     R2,[R4, #+2]
   \   00000046   0x4390             BICS     R0,R0,R2
   \   00000048   0x7188             STRB     R0,[R1, #+6]
   1114              }
   1115          }
   \                     ??OS_EventTaskWaitMulti_2: (+1)
   \   0000004A   0xBC30             POP      {R4,R5}
   \   0000004C   0x4770             BX       LR               ;; return
   1116          #endif
   1117          /*$PAGE*/
   1118          /*
   1119          *********************************************************************************************************
   1120          *                                   REMOVE TASK FROM EVENT WAIT LIST
   1121          *
   1122          * Description: Remove a task from an event's wait list.
   1123          *
   1124          * Arguments  : ptcb     is a pointer to the task to remove.
   1125          *
   1126          *              pevent   is a pointer to the event control block.
   1127          *
   1128          * Returns    : none
   1129          *
   1130          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1131          *********************************************************************************************************
   1132          */
   1133          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1134          void  OS_EventTaskRemove (OS_TCB   *ptcb,
   1135                                    OS_EVENT *pevent)
   1136          {
   \                     OS_EventTaskRemove: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1137              INT8U  y;
   1138          
   1139          
   1140              y                       =  ptcb->OSTCBY;
   \   00000002   0x3034             ADDS     R0,R0,#+52
   \   00000004   0x7802             LDRB     R2,[R0, #+0]
   1141              pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
   \   00000006   0x188A             ADDS     R2,R1,R2
   \   00000008   0x7AD3             LDRB     R3,[R2, #+11]
   \   0000000A   0x7844             LDRB     R4,[R0, #+1]
   \   0000000C   0x43A3             BICS     R3,R3,R4
   \   0000000E   0x72D3             STRB     R3,[R2, #+11]
   1142              if (pevent->OSEventTbl[y] == 0) {
   \   00000010   0xD103             BNE      ??OS_EventTaskRemove_0
   1143                  pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
   \   00000012   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000014   0x7880             LDRB     R0,[R0, #+2]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x728A             STRB     R2,[R1, #+10]
   1144              }
   1145          }
   \                     ??OS_EventTaskRemove_0: (+1)
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
   1146          #endif
   1147          /*$PAGE*/
   1148          /*
   1149          *********************************************************************************************************
   1150          *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
   1151          *
   1152          * Description: Remove a task from multiple events' wait lists.
   1153          *
   1154          * Arguments  : ptcb             is a pointer to the task to remove.
   1155          *
   1156          *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
   1157          *
   1158          * Returns    : none
   1159          *
   1160          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1161          *********************************************************************************************************
   1162          */
   1163          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))

   \                                 In section .text, align 2, keep-with-next
   1164          void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
   1165                                         OS_EVENT **pevents_multi)
   1166          {
   \                     OS_EventTaskRemoveMulti: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1167              OS_EVENT **pevents;
   1168              OS_EVENT  *pevent;
   1169              INT8U      y;
   1170          #if (OS_LOWEST_PRIO <= 63)
   1171              INT8U      bity;
   1172              INT8U      bitx;
   1173          #else
   1174              INT16U     bity;
   1175              INT16U     bitx;
   1176          #endif
   1177          
   1178          
   1179              y       =  ptcb->OSTCBY;
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0x3334             ADDS     R3,R3,#+52
   \   00000006   0x7818             LDRB     R0,[R3, #+0]
   1180              bity    =  ptcb->OSTCBBitY;
   \   00000008   0x789A             LDRB     R2,[R3, #+2]
   1181              bitx    =  ptcb->OSTCBBitX;
   \   0000000A   0x785B             LDRB     R3,[R3, #+1]
   1182              pevents =  pevents_multi;
   1183              pevent  = *pevents;
   \   0000000C   0x680C             LDR      R4,[R1, #+0]
   \   0000000E   0x001F             MOVS     R7,R3
   \   00000010   0xE00A             B        ??OS_EventTaskRemoveMulti_0
   1184              while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
   1185                  pevent->OSEventTbl[y]  &= ~bitx;
   \                     ??OS_EventTaskRemoveMulti_1: (+1)
   \   00000012   0x1825             ADDS     R5,R4,R0
   \   00000014   0x7AEE             LDRB     R6,[R5, #+11]
   \   00000016   0x43BE             BICS     R6,R6,R7
   \   00000018   0x72EE             STRB     R6,[R5, #+11]
   1186                  if (pevent->OSEventTbl[y] == 0) {
   \   0000001A   0xD103             BNE      ??OS_EventTaskRemoveMulti_2
   1187                      pevent->OSEventGrp &= ~bity;
   \   0000001C   0x7AA5             LDRB     R5,[R4, #+10]
   \   0000001E   0x0016             MOVS     R6,R2
   \   00000020   0x43B5             BICS     R5,R5,R6
   \   00000022   0x72A5             STRB     R5,[R4, #+10]
   1188                  }
   1189                  pevents++;
   \                     ??OS_EventTaskRemoveMulti_2: (+1)
   \   00000024   0x1D09             ADDS     R1,R1,#+4
   1190                  pevent = *pevents;
   \   00000026   0x680C             LDR      R4,[R1, #+0]
   1191              }
   \                     ??OS_EventTaskRemoveMulti_0: (+1)
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD1F2             BNE      ??OS_EventTaskRemoveMulti_1
   1192          }
   \   0000002C   0xBCF0             POP      {R4-R7}
   \   0000002E   0x4770             BX       LR               ;; return
   1193          #endif
   1194          /*$PAGE*/
   1195          /*
   1196          *********************************************************************************************************
   1197          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
   1198          *
   1199          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
   1200          *
   1201          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
   1202          *
   1203          * Returns    : none
   1204          *
   1205          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1206          *********************************************************************************************************
   1207          */
   1208          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1209          void  OS_EventWaitListInit (OS_EVENT *pevent)
   1210          {
   1211          #if OS_LOWEST_PRIO <= 63
   1212              INT8U  *ptbl;
   1213          #else
   1214              INT16U *ptbl;
   1215          #endif
   1216              INT8U   i;
   1217          
   1218          
   1219              pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
   \                     OS_EventWaitListInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7281             STRB     R1,[R0, #+10]
   1220              ptbl               = &pevent->OSEventTbl[0];
   \   00000004   0x300B             ADDS     R0,R0,#+11
   1221          
   1222              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0xE002             B        ??OS_EventWaitListInit_0
   1223                  *ptbl++ = 0;
   \                     ??OS_EventWaitListInit_1: (+1)
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   1224              }
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   \                     ??OS_EventWaitListInit_0: (+1)
   \   00000010   0x2A04             CMP      R2,#+4
   \   00000012   0xDBFA             BLT      ??OS_EventWaitListInit_1
   1225          }
   \   00000014   0x4770             BX       LR               ;; return
   1226          #endif
   1227          /*$PAGE*/
   1228          /*
   1229          *********************************************************************************************************
   1230          *                                             INITIALIZATION
   1231          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
   1232          *
   1233          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
   1234          *
   1235          * Arguments  : none
   1236          *
   1237          * Returns    : none
   1238          *********************************************************************************************************
   1239          */
   1240          

   \                                 In section .text, align 2, keep-with-next
   1241          static  void  OS_InitEventList (void)
   1242          {
   \                     OS_InitEventList: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1243          #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
   1244          #if (OS_MAX_EVENTS > 1)
   1245              INT16U     i;
   1246              OS_EVENT  *pevent1;
   1247              OS_EVENT  *pevent2;
   1248          
   1249          
   1250              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
   \   00000002   0x....             LDR      R4,??DataTable26
   \   00000004   0x21A0             MOVS     R1,#+160
   \   00000006   0x0049             LSLS     R1,R1,#+1        ;; #+320
   \   00000008   0x1D20             ADDS     R0,R4,#+4
   \   0000000A   0x.... 0x....      BL       OS_MemClr
   1251              pevent1 = &OSEventTbl[0];
   \   0000000E   0x1D20             ADDS     R0,R4,#+4
   1252              pevent2 = &OSEventTbl[1];
   \   00000010   0x0022             MOVS     R2,R4
   \   00000012   0x3224             ADDS     R2,R2,#+36
   1253              for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x000B             MOVS     R3,R1
   \   00000018   0x000E             MOVS     R6,R1
   \   0000001A   0xE007             B        ??OS_InitEventList_0
   1254                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \                     ??OS_InitEventList_1: (+1)
   \   0000001C   0x7006             STRB     R6,[R0, #+0]
   1255                  pevent1->OSEventPtr     = pevent2;
   \   0000001E   0x6042             STR      R2,[R0, #+4]
   1256          #if OS_EVENT_NAME_SIZE > 1
   1257                  pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
   \   00000020   0x73C5             STRB     R5,[R0, #+15]
   1258                  pevent1->OSEventName[1] = OS_ASCII_NUL;
   \   00000022   0x000D             MOVS     R5,R1
   \   00000024   0x7405             STRB     R5,[R0, #+16]
   1259          #endif
   1260                  pevent1++;
   \   00000026   0x3020             ADDS     R0,R0,#+32
   1261                  pevent2++;
   \   00000028   0x3220             ADDS     R2,R2,#+32
   1262              }
   \   0000002A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??OS_InitEventList_0: (+1)
   \   0000002C   0x253F             MOVS     R5,#+63
   \   0000002E   0x2B09             CMP      R3,#+9
   \   00000030   0xDBF4             BLT      ??OS_InitEventList_1
   1263              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
   \   00000032   0x000A             MOVS     R2,R1
   \   00000034   0x7002             STRB     R2,[R0, #+0]
   1264              pevent1->OSEventPtr             = (OS_EVENT *)0;
   \   00000036   0x6041             STR      R1,[R0, #+4]
   1265          #if OS_EVENT_NAME_SIZE > 1
   1266              pevent1->OSEventName[0]         = '?';
   \   00000038   0x73C5             STRB     R5,[R0, #+15]
   1267              pevent1->OSEventName[1]         = OS_ASCII_NUL;
   \   0000003A   0x7401             STRB     R1,[R0, #+16]
   1268          #endif
   1269              OSEventFreeList                 = &OSEventTbl[0];
   \   0000003C   0x1D20             ADDS     R0,R4,#+4
   \   0000003E   0x6020             STR      R0,[R4, #+0]
   1270          #else
   1271              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
   1272              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1273              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
   1274          #if OS_EVENT_NAME_SIZE > 1
   1275              OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
   1276              OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
   1277          #endif
   1278          #endif
   1279          #endif
   1280          }
   \   00000040   0xBC70             POP      {R4-R6}
   \   00000042   0xBC08             POP      {R3}
   \   00000044   0x4718             BX       R3               ;; return
   1281          /*$PAGE*/
   1282          /*
   1283          *********************************************************************************************************
   1284          *                                             INITIALIZATION
   1285          *                                    INITIALIZE MISCELLANEOUS VARIABLES
   1286          *
   1287          * Description: This function is called by OSInit() to initialize miscellaneous variables.
   1288          *
   1289          * Arguments  : none
   1290          *
   1291          * Returns    : none
   1292          *********************************************************************************************************
   1293          */
   1294          

   \                                 In section .text, align 2, keep-with-next
   1295          static  void  OS_InitMisc (void)
   1296          {
   1297          #if OS_TIME_GET_SET_EN > 0
   1298              OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
   \                     OS_InitMisc: (+1)
   \   00000000   0x....             LDR      R0,??DataTable26_1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6301             STR      R1,[R0, #+48]
   1299          #endif
   1300          
   1301              OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0x7082             STRB     R2,[R0, #+2]
   1302              OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
   \   0000000A   0x70C2             STRB     R2,[R0, #+3]
   1303          
   1304              OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
   \   0000000C   0x7202             STRB     R2,[R0, #+8]
   1305          
   1306              OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
   \   0000000E   0x71C2             STRB     R2,[R0, #+7]
   1307          
   1308              OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
   \   00000010   0x6101             STR      R1,[R0, #+16]
   1309              OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
   \   00000012   0x61C1             STR      R1,[R0, #+28]
   1310          
   1311          #if OS_TASK_STAT_EN > 0
   1312              OSIdleCtrRun  = 0L;
   \   00000014   0x6181             STR      R1,[R0, #+24]
   1313              OSIdleCtrMax  = 0L;
   \   00000016   0x6141             STR      R1,[R0, #+20]
   1314              OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
   \   00000018   0x7041             STRB     R1,[R0, #+1]
   1315          #endif
   1316          }
   \   0000001A   0x4770             BX       LR               ;; return
   1317          /*$PAGE*/
   1318          /*
   1319          *********************************************************************************************************
   1320          *                                             INITIALIZATION
   1321          *                                       INITIALIZE THE READY LIST
   1322          *
   1323          * Description: This function is called by OSInit() to initialize the Ready List.
   1324          *
   1325          * Arguments  : none
   1326          *
   1327          * Returns    : none
   1328          *********************************************************************************************************
   1329          */
   1330          

   \                                 In section .text, align 2, keep-with-next
   1331          static  void  OS_InitRdyList (void)
   1332          {
   \                     OS_InitRdyList: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1333              INT8U    i;
   1334          #if OS_LOWEST_PRIO <= 63
   1335              INT8U   *prdytbl;
   1336          #else
   1337              INT16U  *prdytbl;
   1338          #endif
   1339          
   1340          
   1341              OSRdyGrp      = 0;                                     /* Clear the ready list                     */
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR      R1,??DataTable26_1
   \   00000006   0x0002             MOVS     R2,R0
   \   00000008   0x718A             STRB     R2,[R1, #+6]
   1342              prdytbl       = &OSRdyTbl[0];
   \   0000000A   0x000A             MOVS     R2,R1
   \   0000000C   0x320C             ADDS     R2,R2,#+12
   1343              for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
   \   0000000E   0x0003             MOVS     R3,R0
   \   00000010   0x0004             MOVS     R4,R0
   \   00000012   0xE002             B        ??OS_InitRdyList_0
   1344                  *prdytbl++ = 0;
   \                     ??OS_InitRdyList_1: (+1)
   \   00000014   0x7014             STRB     R4,[R2, #+0]
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   1345              }
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \                     ??OS_InitRdyList_0: (+1)
   \   0000001A   0x2B04             CMP      R3,#+4
   \   0000001C   0xDBFA             BLT      ??OS_InitRdyList_1
   1346          
   1347              OSPrioCur     = 0;
   \   0000001E   0x0002             MOVS     R2,R0
   \   00000020   0x710A             STRB     R2,[R1, #+4]
   1348              OSPrioHighRdy = 0;
   \   00000022   0x714A             STRB     R2,[R1, #+5]
   1349          
   1350              OSTCBHighRdy  = (OS_TCB *)0;
   \   00000024   0x6288             STR      R0,[R1, #+40]
   1351              OSTCBCur      = (OS_TCB *)0;
   \   00000026   0x6208             STR      R0,[R1, #+32]
   1352          }
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
   1353          
   1354          /*$PAGE*/
   1355          /*
   1356          *********************************************************************************************************
   1357          *                                             INITIALIZATION
   1358          *                                         CREATING THE IDLE TASK
   1359          *
   1360          * Description: This function creates the Idle Task.
   1361          *
   1362          * Arguments  : none
   1363          *
   1364          * Returns    : none
   1365          *********************************************************************************************************
   1366          */
   1367          

   \                                 In section .text, align 4, keep-with-next
   1368          static  void  OS_InitTaskIdle (void)
   1369          {
   \                     OS_InitTaskIdle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   1370          #if OS_TASK_NAME_SIZE > 7
   1371              INT8U  err;
   1372          #endif
   1373          
   1374          
   1375          #if OS_TASK_CREATE_EXT_EN > 0
   1376              #if OS_STK_GROWTH == 1
   1377              (void)OSTaskCreateExt(OS_TaskIdle,
   1378                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1379                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
   1380                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1381                                    OS_TASK_IDLE_ID,
   1382                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
   1383                                    OS_TASK_IDLE_STK_SIZE,
   1384                                    (void *)0,                                 /* No TCB extension                     */
   1385                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   \   00000004   0x....             LDR      R0,??DataTable26_2
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x9104             STR      R1,[SP, #+16]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x9103             STR      R1,[SP, #+12]
   \   0000000E   0x2180             MOVS     R1,#+128
   \   00000010   0x9102             STR      R1,[SP, #+8]
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x....             LDR      R1,??DataTable26_3  ;; 0xffff
   \   00000016   0x9100             STR      R1,[SP, #+0]
   \   00000018   0x231F             MOVS     R3,#+31
   \   0000001A   0x21FE             MOVS     R1,#+254
   \   0000001C   0x0049             LSLS     R1,R1,#+1        ;; #+508
   \   0000001E   0x1842             ADDS     R2,R0,R1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR      R0,??DataTable27
   \   00000024   0x.... 0x....      BL       OSTaskCreateExt
   1386              #else
   1387              (void)OSTaskCreateExt(OS_TaskIdle,
   1388                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1389                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1390                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1391                                    OS_TASK_IDLE_ID,
   1392                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
   1393                                    OS_TASK_IDLE_STK_SIZE,
   1394                                    (void *)0,                                 /* No TCB extension                     */
   1395                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1396              #endif
   1397          #else
   1398              #if OS_STK_GROWTH == 1
   1399              (void)OSTaskCreate(OS_TaskIdle,
   1400                                 (void *)0,
   1401                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
   1402                                 OS_TASK_IDLE_PRIO);
   1403              #else
   1404              (void)OSTaskCreate(OS_TaskIdle,
   1405                                 (void *)0,
   1406                                 &OSTaskIdleStk[0],
   1407                                 OS_TASK_IDLE_PRIO);
   1408              #endif
   1409          #endif
   1410          
   1411          #if OS_TASK_NAME_SIZE > 14
   1412              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
   \   00000028   0xAA05             ADD      R2,SP,#+20
   \   0000002A   0x46C0             Nop      
   \   0000002C   0x....             ADR.N    R1,?_0
   \   0000002E   0x201F             MOVS     R0,#+31
   \   00000030   0x.... 0x....      BL       OSTaskNameSet
   1413          #else
   1414          #if OS_TASK_NAME_SIZE > 7
   1415              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
   1416          #endif
   1417          #endif
   1418          }
   \   00000034   0xB007             ADD      SP,SP,#+28
   \   00000036   0xBC08             POP      {R3}
   \   00000038   0x4718             BX       R3               ;; return
   1419          /*$PAGE*/
   1420          /*
   1421          *********************************************************************************************************
   1422          *                                             INITIALIZATION
   1423          *                                      CREATING THE STATISTIC TASK
   1424          *
   1425          * Description: This function creates the Statistic Task.
   1426          *
   1427          * Arguments  : none
   1428          *
   1429          * Returns    : none
   1430          *********************************************************************************************************
   1431          */
   1432          
   1433          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 4, keep-with-next
   1434          static  void  OS_InitTaskStat (void)
   1435          {
   \                     OS_InitTaskStat: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   1436          #if OS_TASK_NAME_SIZE > 7
   1437              INT8U  err;
   1438          #endif
   1439          
   1440          
   1441          #if OS_TASK_CREATE_EXT_EN > 0
   1442              #if OS_STK_GROWTH == 1
   1443              (void)OSTaskCreateExt(OS_TaskStat,
   1444                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1445                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
   1446                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1447                                    OS_TASK_STAT_ID,
   1448                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1449                                    OS_TASK_STAT_STK_SIZE,
   1450                                    (void *)0,                                   /* No TCB extension               */
   1451                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   \   00000004   0x....             LDR      R0,??DataTable27_1
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x9104             STR      R1,[SP, #+16]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x9103             STR      R1,[SP, #+12]
   \   0000000E   0x2180             MOVS     R1,#+128
   \   00000010   0x9102             STR      R1,[SP, #+8]
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x....             LDR      R1,??DataTable27_2  ;; 0xfffe
   \   00000016   0x9100             STR      R1,[SP, #+0]
   \   00000018   0x231E             MOVS     R3,#+30
   \   0000001A   0x21FE             MOVS     R1,#+254
   \   0000001C   0x0049             LSLS     R1,R1,#+1        ;; #+508
   \   0000001E   0x1842             ADDS     R2,R0,R1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR      R0,??DataTable27_3
   \   00000024   0x.... 0x....      BL       OSTaskCreateExt
   1452              #else
   1453              (void)OSTaskCreateExt(OS_TaskStat,
   1454                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1455                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1456                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1457                                    OS_TASK_STAT_ID,
   1458                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
   1459                                    OS_TASK_STAT_STK_SIZE,
   1460                                    (void *)0,                                   /* No TCB extension               */
   1461                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1462              #endif
   1463          #else
   1464              #if OS_STK_GROWTH == 1
   1465              (void)OSTaskCreate(OS_TaskStat,
   1466                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1467                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
   1468                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1469              #else
   1470              (void)OSTaskCreate(OS_TaskStat,
   1471                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1472                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1473                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1474              #endif
   1475          #endif
   1476          
   1477          #if OS_TASK_NAME_SIZE > 14
   1478              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
   \   00000028   0xAA05             ADD      R2,SP,#+20
   \   0000002A   0x46C0             Nop      
   \   0000002C   0x....             ADR.N    R1,?_1
   \   0000002E   0x201E             MOVS     R0,#+30
   \   00000030   0x.... 0x....      BL       OSTaskNameSet
   1479          #else
   1480          #if OS_TASK_NAME_SIZE > 7
   1481              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
   1482          #endif
   1483          #endif
   1484          }
   \   00000034   0xB007             ADD      SP,SP,#+28
   \   00000036   0xBC08             POP      {R3}
   \   00000038   0x4718             BX       R3               ;; return
   1485          #endif
   1486          /*$PAGE*/
   1487          /*
   1488          *********************************************************************************************************
   1489          *                                             INITIALIZATION
   1490          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1491          *
   1492          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1493          *
   1494          * Arguments  : none
   1495          *
   1496          * Returns    : none
   1497          *********************************************************************************************************
   1498          */
   1499          

   \                                 In section .text, align 2, keep-with-next
   1500          static  void  OS_InitTCBList (void)
   1501          {
   \                     OS_InitTCBList: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1502              INT8U    i;
   1503              OS_TCB  *ptcb1;
   1504              OS_TCB  *ptcb2;
   1505          
   1506          
   1507              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   \   00000002   0x....             LDR      R4,??DataTable26_1
   \   00000004   0x21FD             MOVS     R1,#+253
   \   00000006   0x00C9             LSLS     R1,R1,#+3        ;; #+2024
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x3034             ADDS     R0,R0,#+52
   \   0000000C   0x.... 0x....      BL       OS_MemClr
   1508              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   \   00000010   0x2180             MOVS     R1,#+128
   \   00000012   0x....             LDR      R0,??DataTable21_1
   \   00000014   0x.... 0x....      BL       OS_MemClr
   1509              ptcb1 = &OSTCBTbl[0];
   \   00000018   0x0022             MOVS     R2,R4
   \   0000001A   0x3234             ADDS     R2,R2,#+52
   1510              ptcb2 = &OSTCBTbl[1];
   \   0000001C   0x0023             MOVS     R3,R4
   \   0000001E   0x3390             ADDS     R3,R3,#+144
   1511              for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x000D             MOVS     R5,R1
   \   00000024   0xE006             B        ??OS_InitTCBList_0
   1512                  ptcb1->OSTCBNext = ptcb2;
   \                     ??OS_InitTCBList_1: (+1)
   \   00000026   0x6153             STR      R3,[R2, #+20]
   1513          #if OS_TASK_NAME_SIZE > 1
   1514                  ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
   \   00000028   0x7006             STRB     R6,[R0, #+0]
   1515                  ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   0000002A   0x000E             MOVS     R6,R1
   \   0000002C   0x7046             STRB     R6,[R0, #+1]
   1516          #endif
   1517                  ptcb1++;
   \   0000002E   0x325C             ADDS     R2,R2,#+92
   1518                  ptcb2++;
   \   00000030   0x335C             ADDS     R3,R3,#+92
   1519              }
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \                     ??OS_InitTCBList_0: (+1)
   \   00000034   0x0010             MOVS     R0,R2
   \   00000036   0x304C             ADDS     R0,R0,#+76
   \   00000038   0x263F             MOVS     R6,#+63
   \   0000003A   0x2D15             CMP      R5,#+21
   \   0000003C   0xD3F3             BCC      ??OS_InitTCBList_1
   1520              ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
   \   0000003E   0x6151             STR      R1,[R2, #+20]
   1521          #if OS_TASK_NAME_SIZE > 1
   1522              ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
   \   00000040   0x7006             STRB     R6,[R0, #+0]
   1523              ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   00000042   0x000A             MOVS     R2,R1
   \   00000044   0x7042             STRB     R2,[R0, #+1]
   1524          #endif
   1525              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   \   00000046   0x62E1             STR      R1,[R4, #+44]
   1526              OSTCBFreeList           = &OSTCBTbl[0];
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x3034             ADDS     R0,R0,#+52
   \   0000004C   0x6260             STR      R0,[R4, #+36]
   1527          }
   \   0000004E   0xBC70             POP      {R4-R6}
   \   00000050   0xBC08             POP      {R3}
   \   00000052   0x4718             BX       R3               ;; return
   1528          /*$PAGE*/
   1529          /*
   1530          *********************************************************************************************************
   1531          *                                        CLEAR A SECTION OF MEMORY
   1532          *
   1533          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1534          *
   1535          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1536          *
   1537          *              size     is the number of bytes to clear.
   1538          *
   1539          * Returns    : none
   1540          *
   1541          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1542          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1543          *                 of the uses of this function gets close to this limit.
   1544          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1545          *                 of the alignment of the destination.
   1546          *********************************************************************************************************
   1547          */
   1548          

   \                                 In section .text, align 2, keep-with-next
   1549          void  OS_MemClr (INT8U *pdest, INT16U size)
   1550          {
   \                     OS_MemClr: (+1)
   \   00000000   0xE003             B        ??OS_MemClr_0
   1551              while (size > 0) {
   1552                  *pdest++ = (INT8U)0;
   \                     ??OS_MemClr_1: (+1)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x7002             STRB     R2,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   1553                  size--;
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   1554              }
   \                     ??OS_MemClr_0: (+1)
   \   0000000A   0x000A             MOVS     R2,R1
   \   0000000C   0x0412             LSLS     R2,R2,#+16
   \   0000000E   0xD1F8             BNE      ??OS_MemClr_1
   1555          }
   \   00000010   0x4770             BX       LR               ;; return
   1556          /*$PAGE*/
   1557          /*
   1558          *********************************************************************************************************
   1559          *                                        COPY A BLOCK OF MEMORY
   1560          *
   1561          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1562          *              location to another.
   1563          *
   1564          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1565          *
   1566          *              psrc     is a pointer to the 'source'      memory block
   1567          *
   1568          *              size     is the number of bytes to copy.
   1569          *
   1570          * Returns    : none
   1571          *
   1572          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1573          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1574          *                 is not a situation that will happen.
   1575          *              2) Note that we can only copy up to 64K bytes of RAM
   1576          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1577          *                 of the alignment of the source and destination.
   1578          *********************************************************************************************************
   1579          */
   1580          

   \                                 In section .text, align 2, keep-with-next
   1581          void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
   1582          {
   \                     OS_MemCopy: (+1)
   \   00000000   0xE004             B        ??OS_MemCopy_0
   1583              while (size > 0) {
   1584                  *pdest++ = *psrc++;
   \                     ??OS_MemCopy_1: (+1)
   \   00000002   0x780B             LDRB     R3,[R1, #+0]
   \   00000004   0x7003             STRB     R3,[R0, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   1585                  size--;
   \   0000000A   0x1E52             SUBS     R2,R2,#+1
   1586              }
   \                     ??OS_MemCopy_0: (+1)
   \   0000000C   0x0013             MOVS     R3,R2
   \   0000000E   0x041B             LSLS     R3,R3,#+16
   \   00000010   0xD1F7             BNE      ??OS_MemCopy_1
   1587          }
   \   00000012   0x4770             BX       LR               ;; return
   1588          /*$PAGE*/
   1589          /*
   1590          *********************************************************************************************************
   1591          *                                              SCHEDULER
   1592          *
   1593          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1594          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1595          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1596          *
   1597          * Arguments  : none
   1598          *
   1599          * Returns    : none
   1600          *
   1601          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1602          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1603          *********************************************************************************************************
   1604          */
   1605          

   \                                 In section .text, align 2, keep-with-next
   1606          void  OS_Sched (void)
   1607          {
   \                     OS_Sched: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1608          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
   1609              OS_CPU_SR  cpu_sr = 0;
   1610          #endif
   1611          
   1612          
   1613          
   1614              OS_ENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000006   0x0004             MOVS     R4,R0
   1615              if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
   1616                  if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
   \   00000008   0x....             LDR      R5,??DataTable27_4
   \   0000000A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000000C   0x78E9             LDRB     R1,[R5, #+3]
   \   0000000E   0x4301             ORRS     R1,R1,R0
   \   00000010   0xD112             BNE      ??OS_Sched_0
   1617                      OS_SchedNew();
   \   00000012   0x.... 0x....      BL       OS_SchedNew
   1618                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \   00000016   0x7968             LDRB     R0,[R5, #+5]
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0x792A             LDRB     R2,[R5, #+4]
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xD00B             BEQ      ??OS_Sched_0
   1619                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   00000020   0x....             LDR      R1,??DataTable27_5
   \   00000022   0x0080             LSLS     R0,R0,#+2
   \   00000024   0x5808             LDR      R0,[R1, R0]
   \   00000026   0x62A8             STR      R0,[R5, #+40]
   1620          #if OS_TASK_PROFILE_EN > 0
   1621                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \   00000028   0x6B81             LDR      R1,[R0, #+56]
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x6381             STR      R1,[R0, #+56]
   1622          #endif
   1623                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   \   0000002E   0x6928             LDR      R0,[R5, #+16]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x6128             STR      R0,[R5, #+16]
   1624                          OS_TASK_SW();                          /* Perform a context switch                     */
   \   00000034   0x.... 0x....      BL       OSCtxSw
   1625                      }
   1626                  }
   1627              }
   1628              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
   1629          }
   \   0000003E   0xBC31             POP      {R0,R4,R5}
   \   00000040   0xBC08             POP      {R3}
   \   00000042   0x4718             BX       R3               ;; return
   1630          
   1631          
   1632          /*
   1633          *********************************************************************************************************
   1634          *                              FIND HIGHEST PRIORITY TASK READY TO RUN
   1635          *
   1636          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1637          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1638          *
   1639          * Arguments  : none
   1640          *
   1641          * Returns    : none
   1642          *
   1643          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1644          *              2) Interrupts are assumed to be disabled when this function is called.
   1645          *********************************************************************************************************
   1646          */
   1647          

   \                                 In section .text, align 4, keep-with-next
   1648          static  void  OS_SchedNew (void)
   1649          {
   1650          #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
   1651              INT8U   y;
   1652          
   1653          
   1654              y             = OSUnMapTbl[OSRdyGrp];
   \                     OS_SchedNew: (+1)
   \   00000000   0x....             LDR      R0,??DataTable27_4
   \   00000002   0x46C0             Nop      
   \   00000004   0x....             ADR.N    R1,OSUnMapTbl
   \   00000006   0x7982             LDRB     R2,[R0, #+6]
   \   00000008   0x5C8A             LDRB     R2,[R1, R2]
   1655              OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
   \   0000000A   0x00D3             LSLS     R3,R2,#+3
   \   0000000C   0x1882             ADDS     R2,R0,R2
   \   0000000E   0x7B12             LDRB     R2,[R2, #+12]
   \   00000010   0x5C89             LDRB     R1,[R1, R2]
   \   00000012   0x1859             ADDS     R1,R3,R1
   \   00000014   0x7141             STRB     R1,[R0, #+5]
   1656          #else                                            /* We support up to 256 tasks                         */
   1657              INT8U   y;
   1658              INT16U *ptbl;
   1659          
   1660          
   1661              if ((OSRdyGrp & 0xFF) != 0) {
   1662                  y = OSUnMapTbl[OSRdyGrp & 0xFF];
   1663              } else {
   1664                  y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
   1665              }
   1666              ptbl = &OSRdyTbl[y];
   1667              if ((*ptbl & 0xFF) != 0) {
   1668                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
   1669              } else {
   1670                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
   1671              }
   1672          #endif
   1673          }
   \   00000016   0x4770             BX       LR               ;; return
   1674          
   1675          /*$PAGE*/
   1676          /*
   1677          *********************************************************************************************************
   1678          *                                        COPY AN ASCII STRING
   1679          *
   1680          * Description: This function is called by other uC/OS-II services to copy an ASCII string from a 'source'
   1681          *              string to a 'destination' string.
   1682          *
   1683          * Arguments  : pdest    is a pointer to the string that will be receiving the copy.  Note that there MUST
   1684          *                       be sufficient space in the destination storage area to receive this string.
   1685          *
   1686          *              psrc     is a pointer to the source string.  The source string MUST NOT be greater than
   1687          *                       254 characters.
   1688          *
   1689          * Returns    : The size of the string (excluding the NUL terminating character)
   1690          *
   1691          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1692          *********************************************************************************************************
   1693          */
   1694          
   1695          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1696          INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
   1697          {
   \                     OS_StrCopy: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1698              INT8U  len;
   1699          
   1700          
   1701              len = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x0018             MOVS     R0,R3
   \   00000008   0xE003             B        ??OS_StrCopy_0
   1702              while (*psrc != OS_ASCII_NUL) {
   1703                  *pdest++ = *psrc++;
   \                     ??OS_StrCopy_1: (+1)
   \   0000000A   0x7014             STRB     R4,[R2, #+0]
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   1704                  len++;
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   1705              }
   \                     ??OS_StrCopy_0: (+1)
   \   00000012   0x780C             LDRB     R4,[R1, #+0]
   \   00000014   0x0025             MOVS     R5,R4
   \   00000016   0xD1F8             BNE      ??OS_StrCopy_1
   1706              *pdest = OS_ASCII_NUL;
   \   00000018   0x7013             STRB     R3,[R2, #+0]
   1707              return (len);
   \   0000001A   0x0600             LSLS     R0,R0,#+24
   \   0000001C   0x0E00             LSRS     R0,R0,#+24
   \   0000001E   0xBC30             POP      {R4,R5}
   \   00000020   0x4770             BX       LR               ;; return
   1708          }
   1709          #endif
   1710          /*$PAGE*/
   1711          /*
   1712          *********************************************************************************************************
   1713          *                                DETERMINE THE LENGTH OF AN ASCII STRING
   1714          *
   1715          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1716          *              (excluding the NUL character).
   1717          *
   1718          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1719          *
   1720          * Returns    : The size of the string (excluding the NUL terminating character)
   1721          *
   1722          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1723          *              2) The string to check must be less than 255 characters long.
   1724          *********************************************************************************************************
   1725          */
   1726          
   1727          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1728          INT8U  OS_StrLen (INT8U *psrc)
   1729          {
   \                     OS_StrLen: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1730              INT8U  len;
   1731          
   1732          
   1733              len = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE001             B        ??OS_StrLen_0
   1734              while (*psrc != OS_ASCII_NUL) {
   1735                  psrc++;
   \                     ??OS_StrLen_1: (+1)
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   1736                  len++;
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   1737              }
   \                     ??OS_StrLen_0: (+1)
   \   0000000A   0x780A             LDRB     R2,[R1, #+0]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD1FA             BNE      ??OS_StrLen_1
   1738              return (len);
   \   00000010   0x0600             LSLS     R0,R0,#+24
   \   00000012   0x0E00             LSRS     R0,R0,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1739          }
   1740          #endif
   1741          /*$PAGE*/
   1742          /*
   1743          *********************************************************************************************************
   1744          *                                              IDLE TASK
   1745          *
   1746          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1747          *              executes because they are ALL waiting for event(s) to occur.
   1748          *
   1749          * Arguments  : none
   1750          *
   1751          * Returns    : none
   1752          *
   1753          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1754          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1755          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1756          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1757          *                 interrupts.
   1758          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1759          *                 power.
   1760          *********************************************************************************************************
   1761          */
   1762          

   \                                 In section .text, align 2, keep-with-next
   1763          void  OS_TaskIdle (void *p_arg)
   1764          {
   \                     OS_TaskIdle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1765          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1766              OS_CPU_SR  cpu_sr = 0;
   1767          #endif
   1768          
   1769          
   1770          
   1771              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   1772              for (;;) {
   1773                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskIdle_0: (+1)
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
   1774                  OSIdleCtr++;
   \   00000006   0x....             LDR      R1,??DataTable27_4
   \   00000008   0x69CA             LDR      R2,[R1, #+28]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x61CA             STR      R2,[R1, #+28]
   1775                  OS_EXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Restore
   1776                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \   00000012   0x.... 0x....      BL       OSTaskIdleHook
   \   00000016   0xE7F4             B        ??OS_TaskIdle_0
   1777              }
   1778          }
   1779          /*$PAGE*/
   1780          /*
   1781          *********************************************************************************************************
   1782          *                                            STATISTICS TASK
   1783          *
   1784          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1785          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1786          *              CPU usage is determined by:
   1787          *
   1788          *                                          OSIdleCtr
   1789          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1790          *                                         OSIdleCtrMax
   1791          *
   1792          * Arguments  : parg     this pointer is not used at this time.
   1793          *
   1794          * Returns    : none
   1795          *
   1796          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1797          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1798          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1799          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1800          *                 maximum value for the idle counter.
   1801          *********************************************************************************************************
   1802          */
   1803          
   1804          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1805          void  OS_TaskStat (void *p_arg)
   1806          {
   \                     OS_TaskStat: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1807          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1808              OS_CPU_SR  cpu_sr = 0;
   1809          #endif
   1810          
   1811          
   1812          
   1813              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   \   00000002   0x....             LDR      R4,??DataTable27_4
   \   00000004   0xE002             B        ??OS_TaskStat_0
   1814              while (OSStatRdy == OS_FALSE) {
   1815                  OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
   \                     ??OS_TaskStat_1: (+1)
   \   00000006   0x20C8             MOVS     R0,#+200
   \   00000008   0x.... 0x....      BL       OSTimeDly
   1816              }
   \                     ??OS_TaskStat_0: (+1)
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD0F9             BEQ      ??OS_TaskStat_1
   1817              OSIdleCtrMax /= 100L;
   \   00000012   0x6960             LDR      R0,[R4, #+20]
   \   00000014   0x2164             MOVS     R1,#+100
   \   00000016   0x.... 0x....      BL       __aeabi_uidiv
   \   0000001A   0x6160             STR      R0,[R4, #+20]
   1818              if (OSIdleCtrMax == 0L) {
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD104             BNE      ??OS_TaskStat_2
   1819                  OSCPUUsage = 0;
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x7020             STRB     R0,[R4, #+0]
   1820                  (void)OSTaskSuspend(OS_PRIO_SELF);
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0x.... 0x....      BL       OSTaskSuspend
   1821              }
   1822              for (;;) {
   1823                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskStat_2: (+1)
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Save
   1824                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   \   00000030   0x69E1             LDR      R1,[R4, #+28]
   \   00000032   0x61A1             STR      R1,[R4, #+24]
   1825                  OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
   \   00000034   0x61E5             STR      R5,[R4, #+28]
   1826                  OS_EXIT_CRITICAL();
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
   1827                  OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
   \   0000003A   0x2664             MOVS     R6,#+100
   \   0000003C   0x69A0             LDR      R0,[R4, #+24]
   \   0000003E   0x6961             LDR      R1,[R4, #+20]
   \   00000040   0x.... 0x....      BL       __aeabi_uidiv
   \   00000044   0x1A30             SUBS     R0,R6,R0
   \   00000046   0x7020             STRB     R0,[R4, #+0]
   1828                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   \   00000048   0x.... 0x....      BL       OSTaskStatHook
   1829          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
   1830                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   \   0000004C   0x.... 0x....      BL       OS_TaskStatStkChk
   1831          #endif
   1832                  OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       OSTimeDly
   \   00000056   0xE7E9             B        ??OS_TaskStat_2
   1833              }
   1834          }
   1835          #endif
   1836          /*$PAGE*/
   1837          /*
   1838          *********************************************************************************************************
   1839          *                                      CHECK ALL TASK STACKS
   1840          *
   1841          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1842          *
   1843          * Arguments  : none
   1844          *
   1845          * Returns    : none
   1846          *********************************************************************************************************
   1847          */
   1848          
   1849          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
   1850          void  OS_TaskStatStkChk (void)
   1851          {
   \                     OS_TaskStatStkChk: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1852              OS_TCB      *ptcb;
   1853              OS_STK_DATA  stk_data;
   1854              INT8U        err;
   1855              INT8U        prio;
   1856          
   1857          
   1858              for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE014             B        ??OS_TaskStatStkChk_0
   1859                  err = OSTaskStkChk(prio, &stk_data);
   1860                  if (err == OS_ERR_NONE) {
   \                     ??OS_TaskStatStkChk_1: (+1)
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       OSTaskStkChk
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD10D             BNE      ??OS_TaskStatStkChk_2
   1861                      ptcb = OSTCBPrioTbl[prio];
   \   00000014   0x....             LDR      R0,??DataTable27_5
   \   00000016   0x00A9             LSLS     R1,R5,#+2
   \   00000018   0x5840             LDR      R0,[R0, R1]
   1862                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD008             BEQ      ??OS_TaskStatStkChk_2
   1863                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD006             BEQ      ??OS_TaskStatStkChk_2
   1864          #if OS_TASK_PROFILE_EN > 0
   1865                              #if OS_STK_GROWTH == 1
   1866                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   \   00000022   0x6881             LDR      R1,[R0, #+8]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0x0092             LSLS     R2,R2,#+2
   \   00000028   0x1889             ADDS     R1,R1,R2
   \   0000002A   0x6441             STR      R1,[R0, #+68]
   1867                              #else
   1868                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1869                              #endif
   1870                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
   \   0000002C   0x9901             LDR      R1,[SP, #+4]
   \   0000002E   0x6481             STR      R1,[R0, #+72]
   1871          #endif
   1872                          }
   1873                      }
   1874                  }
   1875              }
   \                     ??OS_TaskStatStkChk_2: (+1)
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \                     ??OS_TaskStatStkChk_0: (+1)
   \   00000032   0x0624             LSLS     R4,R4,#+24
   \   00000034   0x0E24             LSRS     R4,R4,#+24
   \   00000036   0x0025             MOVS     R5,R4
   \   00000038   0x2D20             CMP      R5,#+32
   \   0000003A   0xDBE5             BLT      ??OS_TaskStatStkChk_1
   1876          }
   \   0000003C   0xBC37             POP      {R0-R2,R4,R5}
   \   0000003E   0xBC08             POP      {R3}
   \   00000040   0x4718             BX       R3               ;; return
   1877          #endif
   1878          /*$PAGE*/
   1879          /*
   1880          *********************************************************************************************************
   1881          *                                            INITIALIZE TCB
   1882          *
   1883          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1884          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1885          *
   1886          * Arguments  : prio          is the priority of the task being created
   1887          *
   1888          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1889          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1890          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1891          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1892          *                            specific.
   1893          *
   1894          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1895          *                            'OSTaskCreate()'.
   1896          *
   1897          *              id            is the task's ID (0..65535)
   1898          *
   1899          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1900          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1901          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1902          *                            units are established by the #define constant OS_STK which is CPU
   1903          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1904          *
   1905          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1906          *                            control block.  This allows you to store the contents of floating-point
   1907          *                            registers, MMU registers or anything else you could find useful during a
   1908          *                            context switch.  You can even assign a name to each task and store this name
   1909          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1910          *
   1911          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1912          *                            0 if called from 'OSTaskCreate()'.
   1913          *
   1914          * Returns    : OS_ERR_NONE         if the call was successful
   1915          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1916          *                                  be created.
   1917          *
   1918          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1919          *********************************************************************************************************
   1920          */
   1921          

   \                                 In section .text, align 2, keep-with-next
   1922          INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
   1923          {
   \                     OS_TCBInit: (+1)
   \   00000000   0xB5FD             PUSH     {R0,R2-R7,LR}
   \   00000002   0x000D             MOVS     R5,R1
   1924              OS_TCB    *ptcb;
   1925          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
   1926              OS_CPU_SR  cpu_sr = 0;
   1927          #endif
   1928          
   1929          
   1930          
   1931              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   1932              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \   00000008   0x....             LDR      R7,??DataTable27_4
   \   0000000A   0x6A7C             LDR      R4,[R7, #+36]
   1933              if (ptcb != (OS_TCB *)0) {
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD05F             BEQ      ??OS_TCBInit_0
   1934                  OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
   \   00000010   0x6961             LDR      R1,[R4, #+20]
   \   00000012   0x6279             STR      R1,[R7, #+36]
   1935                  OS_EXIT_CRITICAL();
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Restore
   1936                  ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
   \   00000018   0x6025             STR      R5,[R4, #+0]
   1937                  ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
   \   0000001A   0x0025             MOVS     R5,R4
   \   0000001C   0x3530             ADDS     R5,R5,#+48
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x70A8             STRB     R0,[R5, #+2]
   1938                  ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
   \   00000024   0x2600             MOVS     R6,#+0
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x7028             STRB     R0,[R5, #+0]
   1939                  ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
   \   0000002A   0x7068             STRB     R0,[R5, #+1]
   1940                  ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
   \   0000002C   0x85E0             STRH     R0,[R4, #+46]
   1941          
   1942          #if OS_TASK_CREATE_EXT_EN > 0
   1943                  ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
   \   0000002E   0x9809             LDR      R0,[SP, #+36]
   \   00000030   0x6060             STR      R0,[R4, #+4]
   1944                  ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
   \   00000032   0x9808             LDR      R0,[SP, #+32]
   \   00000034   0x60E0             STR      R0,[R4, #+12]
   1945                  ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
   \   00000036   0x9801             LDR      R0,[SP, #+4]
   \   00000038   0x60A0             STR      R0,[R4, #+8]
   1946                  ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
   \   0000003A   0x980A             LDR      R0,[SP, #+40]
   \   0000003C   0x8220             STRH     R0,[R4, #+16]
   1947                  ptcb->OSTCBId            = id;                     /* Store task ID                            */
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x8900             LDRH     R0,[R0, #+8]
   \   00000042   0x8260             STRH     R0,[R4, #+18]
   1948          #else
   1949                  pext                     = pext;                   /* Prevent compiler warning if not used     */
   1950                  stk_size                 = stk_size;
   1951                  pbos                     = pbos;
   1952                  opt                      = opt;
   1953                  id                       = id;
   1954          #endif
   1955          
   1956          #if OS_TASK_DEL_EN > 0
   1957                  ptcb->OSTCBDelReq        = OS_ERR_NONE;
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0x71E8             STRB     R0,[R5, #+7]
   1958          #endif
   1959          
   1960          #if OS_LOWEST_PRIO <= 63
   1961                  ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x08C0             LSRS     R0,R0,#+3
   \   0000004E   0x7128             STRB     R0,[R5, #+4]
   1962                  ptcb->OSTCBX             = (INT8U)(prio & 0x07);
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x0740             LSLS     R0,R0,#+29
   \   00000056   0x0F40             LSRS     R0,R0,#+29
   \   00000058   0x70E8             STRB     R0,[R5, #+3]
   1963                  ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x7929             LDRB     R1,[R5, #+4]
   \   0000005E   0x0002             MOVS     R2,R0
   \   00000060   0x408A             LSLS     R2,R2,R1
   \   00000062   0x71AA             STRB     R2,[R5, #+6]
   1964                  ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
   \   00000064   0x78E9             LDRB     R1,[R5, #+3]
   \   00000066   0x4088             LSLS     R0,R0,R1
   \   00000068   0x7168             STRB     R0,[R5, #+5]
   1965          #else
   1966                  ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
   1967                  ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
   1968                  ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
   1969                  ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
   1970          #endif
   1971          
   1972          #if (OS_EVENT_EN)
   1973                  ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
   \   0000006A   0x61E6             STR      R6,[R4, #+28]
   1974          #if (OS_EVENT_MULTI_EN > 0)
   1975                  ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
   \   0000006C   0x6226             STR      R6,[R4, #+32]
   1976          #endif
   1977          #endif
   1978          
   1979          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
   1980                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \   0000006E   0x62A6             STR      R6,[R4, #+40]
   1981          #endif
   1982          
   1983          #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
   1984                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \   00000070   0x6266             STR      R6,[R4, #+36]
   1985          #endif
   1986          
   1987          #if OS_TASK_PROFILE_EN > 0
   1988                  ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
   \   00000072   0x60AE             STR      R6,[R5, #+8]
   1989                  ptcb->OSTCBCyclesStart = 0L;
   \   00000074   0x612E             STR      R6,[R5, #+16]
   1990                  ptcb->OSTCBCyclesTot   = 0L;
   \   00000076   0x60EE             STR      R6,[R5, #+12]
   1991                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \   00000078   0x616E             STR      R6,[R5, #+20]
   1992                  ptcb->OSTCBStkUsed     = 0L;
   \   0000007A   0x61AE             STR      R6,[R5, #+24]
   1993          #endif
   1994          
   1995          #if OS_TASK_NAME_SIZE > 1
   1996                  ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
   \   0000007C   0x203F             MOVS     R0,#+63
   \   0000007E   0x7728             STRB     R0,[R5, #+28]
   1997                  ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0x7768             STRB     R0,[R5, #+29]
   1998          #endif
   1999          
   2000                  OSTCBInitHook(ptcb);
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       OSTCBInitHook
   2001          
   2002                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       OSTaskCreateHook
   2003          
   2004                  OS_ENTER_CRITICAL();
   \   00000090   0x.... 0x....      BL       OS_CPU_SR_Save
   2005                  OSTCBPrioTbl[prio] = ptcb;
   \   00000094   0x....             LDR      R1,??DataTable27_5
   \   00000096   0x466A             MOV      R2,SP
   \   00000098   0x7812             LDRB     R2,[R2, #+0]
   \   0000009A   0x0092             LSLS     R2,R2,#+2
   \   0000009C   0x508C             STR      R4,[R1, R2]
   2006                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   \   0000009E   0x6AF9             LDR      R1,[R7, #+44]
   \   000000A0   0x6161             STR      R1,[R4, #+20]
   2007                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \   000000A2   0x61A6             STR      R6,[R4, #+24]
   2008                  if (OSTCBList != (OS_TCB *)0) {
   \   000000A4   0x6AF9             LDR      R1,[R7, #+44]
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD000             BEQ      ??OS_TCBInit_1
   2009                      OSTCBList->OSTCBPrev = ptcb;
   \   000000AA   0x618C             STR      R4,[R1, #+24]
   2010                  }
   2011                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_1: (+1)
   \   000000AC   0x62FC             STR      R4,[R7, #+44]
   2012                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \   000000AE   0x79B9             LDRB     R1,[R7, #+6]
   \   000000B0   0x79AA             LDRB     R2,[R5, #+6]
   \   000000B2   0x430A             ORRS     R2,R2,R1
   \   000000B4   0x71BA             STRB     R2,[R7, #+6]
   2013                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000000B6   0x7929             LDRB     R1,[R5, #+4]
   \   000000B8   0x1879             ADDS     R1,R7,R1
   \   000000BA   0x7B0A             LDRB     R2,[R1, #+12]
   \   000000BC   0x796B             LDRB     R3,[R5, #+5]
   \   000000BE   0x4313             ORRS     R3,R3,R2
   \   000000C0   0x730B             STRB     R3,[R1, #+12]
   2014                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \   000000C2   0x7A39             LDRB     R1,[R7, #+8]
   \   000000C4   0x1C49             ADDS     R1,R1,#+1
   \   000000C6   0x7239             STRB     R1,[R7, #+8]
   2015                  OS_EXIT_CRITICAL();
   \   000000C8   0x.... 0x....      BL       OS_CPU_SR_Restore
   2016                  return (OS_ERR_NONE);
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0xE002             B        ??OS_TCBInit_2
   2017              }
   2018              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0: (+1)
   \   000000D0   0x.... 0x....      BL       OS_CPU_SR_Restore
   2019              return (OS_ERR_TASK_NO_MORE_TCB);
   \   000000D4   0x2042             MOVS     R0,#+66
   \                     ??OS_TCBInit_2: (+1)
   \   000000D6   0xBCFE             POP      {R1-R7}
   \   000000D8   0xBC08             POP      {R3}
   \   000000DA   0x4718             BX       R3               ;; return
   2020          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     OSCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     OSCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/OS-II Idle"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x49    
   \              0x64 0x6C    
   \              0x65 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     OSUnMapTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     OSCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     OSTaskIdleStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     OS_TaskIdle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     OSTaskStatStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x0000FFFE         DC32     0xfffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     OS_TaskStat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x........         DC32     OSCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x75 0x43          DC8 "uC/OS-II Stat"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x74 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSEventNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
      24   OSEventNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
        24   -> OS_StrLen
      40   OSEventPendMulti
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
        40   -> OS_EventTaskRemoveMulti
        40   -> OS_EventTaskWaitMulti
        40   -> OS_Sched
       8   OSInit
         8   -> OSDebugInit
         8   -> OSInitHookBegin
         8   -> OSInitHookEnd
         8   -> OS_FlagInit
         8   -> OS_InitEventList
         8   -> OS_InitMisc
         8   -> OS_InitRdyList
         8   -> OS_InitTCBList
         8   -> OS_InitTaskIdle
         8   -> OS_InitTaskStat
       0   OSIntEnter
      16   OSIntExit
        16   -> OSIntCtxSw
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_SchedNew
       8   OSSchedLock
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
       8   OSSchedUnlock
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_Sched
       8   OSStart
         8   -> OSStartHighRdy
         8   -> OS_SchedNew
       8   OSStatInit
         8   -> OSTimeDly
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      16   OSTimeTick
        16   -> OSTimeTickHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       0   OSVersion
       0   OS_Dummy
      24   OS_EventTaskRdy
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskRemoveMulti
       4   OS_EventTaskRemove
      16   OS_EventTaskRemoveMulti
       4   OS_EventTaskWait
       8   OS_EventTaskWaitMulti
       0   OS_EventWaitListInit
      16   OS_InitEventList
        16   -> OS_MemClr
       0   OS_InitMisc
       4   OS_InitRdyList
      16   OS_InitTCBList
        16   -> OS_MemClr
      32   OS_InitTaskIdle
        32   -> OSTaskCreateExt
        32   -> OSTaskNameSet
      32   OS_InitTaskStat
        32   -> OSTaskCreateExt
        32   -> OSTaskNameSet
       0   OS_MemClr
       0   OS_MemCopy
      16   OS_Sched
        16   -> OSCtxSw
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_SchedNew
       0   OS_SchedNew
       8   OS_StrCopy
       0   OS_StrLen
      32   OS_TCBInit
        32   -> OSTCBInitHook
        32   -> OSTaskCreateHook
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
       8   OS_TaskIdle
         8   -> OSTaskIdleHook
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      16   OS_TaskStat
        16   -> OSTaskStatHook
        16   -> OSTaskSuspend
        16   -> OSTimeDly
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_TaskStatStkChk
        16 __aeabi_uidiv
      24   OS_TaskStatStkChk
        24   -> OSTaskStkChk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable7
      16  ?_0
      16  ?_1
    2076  OSCPUUsage
          OSStatRdy
          OSIntNesting
          OSLockNesting
          OSPrioCur
          OSPrioHighRdy
          OSRdyGrp
          OSRunning
          OSTaskCtr
          OSTickStepState
          OSRdyTbl
          OSCtxSwCtr
          OSIdleCtrMax
          OSIdleCtrRun
          OSIdleCtr
          OSTCBCur
          OSTCBFreeList
          OSTCBHighRdy
          OSTCBList
          OSTime
          OSTCBTbl
     324  OSEventFreeList
          OSEventTbl
      76  OSEventNameGet
      90  OSEventNameSet
     486  OSEventPendMulti
       4  OSFlagFreeList
     140  OSFlagTbl
      46  OSInit
      20  OSIntEnter
      84  OSIntExit
      40  OSSchedLock
      66  OSSchedUnlock
      38  OSStart
      50  OSStatInit
     128  OSTCBPrioTbl
     512  OSTaskIdleStk
     512  OSTaskStatStk
     166  OSTimeTick
     256  OSUnMapTbl
       6  OSVersion
       2  OS_Dummy
     108  OS_EventTaskRdy
      30  OS_EventTaskRemove
      48  OS_EventTaskRemoveMulti
      66  OS_EventTaskWait
      78  OS_EventTaskWaitMulti
      22  OS_EventWaitListInit
      70  OS_InitEventList
      28  OS_InitMisc
      44  OS_InitRdyList
      84  OS_InitTCBList
      58  OS_InitTaskIdle
      58  OS_InitTaskStat
      18  OS_MemClr
      20  OS_MemCopy
      68  OS_Sched
      24  OS_SchedNew
      34  OS_StrCopy
      22  OS_StrLen
     220  OS_TCBInit
      24  OS_TaskIdle
      88  OS_TaskStat
      66  OS_TaskStatStkChk

 
 3 696 bytes in section .bss
 2 796 bytes in section .text
 
 2 796 bytes of CODE memory
 3 696 bytes of DATA memory

Errors: none
Warnings: none
